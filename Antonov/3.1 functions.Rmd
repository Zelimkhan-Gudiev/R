---
title: "Функции"
author: "<i>Основы программирования на R</i><br><br>Антон Антонов"
output: 
  revealjs::revealjs_presentation:
    theme: serif
    highlight: tango
    center: false
    transition: fade
    pandoc_args: [ 
      "--slide-level", "1", 
      "--include-in-header", "custom.css"
    ]
---

```{r setup, echo=FALSE}
options(width = 110)
```

# Функция как объект

Функция в R -- объект "первого класса", её можно:

. . .

Использовать как обычный объект
```{r}
str(c(mean, max))
fun_list <- c(mean, max)
sapply(fun_list, function(f) f(1:100))
sapply(iris[sapply(iris, is.numeric)], mean)

c(mean, min, max) %>% 
  sapply(function(f) f(1:100))
```

## Комментарии
--
Друзья, возник вопрос по коду в самом начале видео:
fun_list<-c(mean,max)
sapply(fun_list, function(f) f(0:100))
1) В анонимной функции   function(f) f(0:100)  откуда  интерпретатор знает, что такое f?
2) Почему в sapply на месте объекта стоит функция?
То есть должно же было быть наоборот - сначала список объектов, к которым применится функция. 
А потом к ним должны были бы применяться функции. Здесь же на месте объектов указаны функции.
--
Мне тоже не сразу понятно было. Вам уже не нужно, скорее всего, но для будущих поколений оставлю
2) fun_list - это список, поэтому sapply съедает его в качестве объекта и подставляет каждый элемент в function(f)
1) Интерпретатор понимает, что такое f, потому что мы указали f как параметр в функции. И вместо f подставляется содержимое fun_list.
В нашем случае получается mean(1:100) и max(1:100)
Я так понял. Если где-то ошибаюсь, извиняюсь и прошу поправить.


# Функция как аргумент

. . .

Указывать в качестве аргумента

```{r}
fun_list <- c(mean, max)
apply_f <- function(f, x) f(x)
sapply(fun_list, apply_f, x = 1:100)

```
apply_f это функция, которая применяет f к х

sapply(list, function ...)
В данном случае:
1) list - это две функции (fun_list).
2) function - функция "apply_f", содержащая два агрумента, и которая применяет первый агрумент к второму агрументу: 
  а) первый агрумент это функция "f", которая должна быть применена по отношению к второму агрументу "х".
  b) второй аргумент "х" это объект по отношению к которому должна быть применена функция "f"
3) x = 1:100 - агрументы (optional arguments to FUN), который sapply передает функции, которая указана в качестве второго агрумента

При выполнении функции sapply происходит следующее:
1) Элементы листа "fun_list" (mean, max) передаются в функцию apply_f (function(f, x) f(x)). Получается так: function(mean, x) mean(x),
                                                                                                             function(max, x) meax(x)
2) т.к. sapply нужны только два агрумента, то все ослтальные агрументы она передает функции, которую она применяет.
Т.е. функции, указанной в sapply в качестве второго аргумента apply_f или (function(f, x) f(x)) или в нашем случае function(mean, x) mean(x)
. . .
--
# 
... при этом анонимная функция тоже подойдёт

```{r}
apply_f(function(x) sum(x^2), 1:10)
```

# Функция как return value

Использовать как возвращаемое значение

```{r}
square <- function() function(x) x^2
square()
square()(5)
```

# Функции внутри функций

. . .

```{r}
f <- function(x) {
  g <- function(y) if (y > 0) 1 else if (y < 0) -1 else 0
  sapply(x, g)
}
all.equal(f(-100:100), sign(-100:100))
f(seq(-10, 10, by = 2))

```

. . .

Идеальный случай: если функция `g` нужна только внутри функции `f` и не очень громоздка

Функция внутри функции -- один из вариантов инкапсуляции в R

# Исходный код функции

. . .

Простейший случай: напечатать имя функции без скобок (напр., `sd`)

```{r}
sd
(f <- function(x) x^5)
var
```

. . .

Если в выводе есть `.C`, `.Call`, `.Fortran`, `.External`, `.Internal`, `.Primitive`, то это обращение к скомпилированному коду: нужно смотреть исходный код R (напр., `var`)

. . .

Если в выводе есть `UseMethod` или `standardGeneric`, то это method dispatch для классов S3/S4 (полиморфизм; напр., `plot`)

```{r}
methods(plot)[1:20]
```

Полное описание всех случаев: [http://stackoverflow.com/questions/19226816/how-can-i-view-the-source-code-for-a-function](http://stackoverflow.com/questions/19226816/how-can-i-view-the-source-code-for-a-function)

# Возвращаемое значение

. . .

Определяется либо ключевым словом `return`: 
```{r}
has_na <- function(v) {
  for (k in v) if (is.na(k)) return(TRUE)
  return(FALSE)
}
```

. . .

либо последним вычисленным значением:
```{r}
has_na <- function(v) any(is.na(v))
```

# Аргументы по умолчанию

. . .

Посмотрите, как объявлена функция `seq`:

```{r, eval=FALSE}
seq(from = 1, to = 1, by = ((to - from)/(length.out - 1)),
    length.out = NULL, along.with = NULL, ...)
```

. . .

>- Аргументы могут иметь значения по умолчанию
>- Значения могут вычисляться на лету!

. . .
```{r}
seq() # from = 1, to = 1
seq(1, 5, length.out = 11) # by = (5 - 1)/(11 - 1) = 0.4
```

# Правила разбора аргументов

. . .

Рассмотрим на примере:

```{r, eval=FALSE}
f <- function(arg1, arg2, remove_na = TRUE, ..., optional_arg) {}
f(1, arg2 = 2, remove = F, optional_arg = 42, do_magic = TRUE)
```

. . .

Разбор аргументов проходит в три этапа:

1. Точное совпадение имени аргумента -- `arg2`, `optional_arg`
2. Частичное совпадение имени аргумента (только до `...`) -- `remove_na`
3. Разбор аргументов по позиции -- `arg1`

Неразобранные аргументы попадают в `...` -- `do_magic`

# Проброс аргументов

. . .

Один случай использования ellipsis -- "произвольное количество передаваемых объектов", функции `sum`, `c`, `cbind`, `paste`

. . .

Другой характерный случай -- "проброс аргументов":

```{r}
f <- function(x, pow = 2) x^pow
integrate(f, 0, 1) # lower = 0, upper = 1, pow = 2
integrate(f, 0, 1, pow = 5) # same, but pow = 5
```

# Бинарные операторы

Оператор `x %in% y`: есть ли вхождения элементов `x` в `y`? 
```{r}
1:5 %in% c(1, 2, 5)
```

. . .

```{r}
"%nin%" <- function(x, y) !(x %in% y)
1:5 %nin% c(1, 2, 5)
```
# Step 3
Чтобы глубже прочувствовать частичное дополнение аргументов функции, давайте рассмотрим "полный" вызов функции seq (x, y и z -- числа): 
```{r}
seq(from = x, to = y, by = z)
```
Какие из следующих вызовов эквивалентны этому? 
Убедитесь, что вы понимаете, почему так происходит.
P.S. Злоупотреблять этими возможностями не стоит. Выбирайте разумный компромисс между частичным дополнением и удобочитаемостью.
```{r}
seq(by = z, x, y)
seq(to = y, by = z, from = x)
seq(y, z, fr = x)
seq(x, y, z)
seq(b = z, f = x, t = y)
x <- 1
y <- 10
z <- 2
```

# Step 4
Одна интересная конструкция, о которой я рассказал, может быть использована для передачи произвольного количества аргументов далее по стеку вызовов вложенных функций. С помощью этой конструкции напишите такую функцию, которая займётся украшением строк.
Пусть функция decorate_string действует поверх функции paste, дополнительно приклеивая к результату аргумент pattern. При этом этот аргумент должен быть присоединён как в начале строки (строк), так и в конце, но перевёрнутый задом наперёд.
Тут проще всего показать на примерах:
```{r}
decorate_string(pattern = "123", "abc")            # "123abc321"
decorate_string(pattern = "123", "abc", "def")     # "123abc def321"
decorate_string(pattern = "123", c("abc", "def"))  # "123abc321" "123def321" (вектор длины 2)
```
Обратите внимание, что функция decorate_string должна помнить про аргументы для paste и правильно на них реагировать:
```{r}
decorate_string(pattern = "123", "abc", "def", sep = "+")    # "123abc+def321"
decorate_string(pattern = "!", c("x", "x"), collapse = "_")  # "!x_x!"
decorate_string(pattern = ".:", 1:2, 3:4, 5:6, sep = "&")    # ".:1&3&5:." ".:2&4&6:." (вектор длины 2)
```
Подсказки: 
если вам нужна утилитарная функция для какого-то простого промежуточного действия, напишите и проверьте её отдельно;
в шаблоне для отправки <???> означает то место, которое нужно написать самостоятельно;
убедитесь, что результат для вызовов выше в точности такой, как я указал!
P.S. Функции такого рода не праздное развлечение: похожие задачи могут возникать при построении путей к файлам или, например, HTTP запросов.
```{r}
decorate_string <- function(pattern, ...) {
  rev_pat <- stri_reverse(pattern)
  paste0(pattern, ... , rev_pat)
}

decorate_string(pattern = "123", "abc", "def")
decorate_string(pattern = "123", c("abc", "def"))

str_length(c("abc", "def"))

length(c("abc", "def"))
length("abc", "def")

paste("123", "abc", sep = "")
paste("123", c("abc", "def"), sep = "", collapse = " ")
paste("123", c("abc", "def"), sep = "")
pattern <- "123"
stri_reverse("123")

install.packages("stringi")
library(stringi)
library(stringr)
```


# Глоссарий

. . .

`?"function"`

Source code for functions, `?methods`

Argument matching, ellipsis (`?"..."`)