remove(list = ls())

#### Contens https://habr.com/ru/company/infopulse/blog/274611/ ####

# Это вводная статья об использовании apply, sapply и lapply, она лучше всего подходит для людей, 
# которые недавно работают с R или незнакомы с этими функциями. Я приведу несколько примеров 
# использования функций семейства apply, поскольку они часто применяются при работе в R.



#### Packages and librarys ####

install.packages("dplyr")
library(dplyr)
install.packages("psych")
library(psych)

####
m <- matrix(data = cbind(rnorm(30, 0), rnorm(30, 2), rnorm(30, 5)), nrow = 30, ncol = 3)
apply(m, 1, mean) # ср. значение по строкам
apply(m, 2, mean) # ср. значение по столбцам

#### Использование apply ####

# Давайте узнаем, сколько отрицательных чисел в каждой колонке, снова применив apply
apply(m, 2, function(x) length(x[x < 0]))

apply(m, 2, function(x) is.matrix(x))

apply(m, 2, is.vector)


# Почему же тогда нужно было оборачивать в функцию length? Когда мы хотим определить свой 
# собственный обработчик для apply, мы должны как минимум задать имя входной переменной, 
# чтобы использовать его в функции:

apply(m, 2, length(x[x<0]))
# Error in match.fun(FUN) : object 'x' not found

apply(m, 2, function(x) mean(x[x>0]))


#### Использование sapply и lapply ####

# Эти две функции работают похожим образом, представляя набор данных как список или вектор и применяя заданную функцию 
# к каждому элементу. Иногда нам требуется что-то больше, чем линейное преобразование данных. Например, 
# мы захотели бы сравнить текущее значение со значением пять отрезков времени назад. Возможно, стоит 
# применить rollapply для этого, но быстрый, хотя и не совсем красивый способ — запустить sapply или lapply, 
# передав набор индексированных значений.
# Здесь мы применим sapply, который работает со списком или вектором данных:

sapply(1:3, function(x) x^2)
# vec <- 1:3 vec^2

# lapply очень похожа, но возвращает список, а не вектор:
lapply(1:3, function(x) x^2)

# Передав в sapply simplify=FALSE, также получите список:
sapply(1:3, function(x) x^2, simplify=F)


# Также можно применить unlist с lapply, чтобы получить вектор.
unlist(lapply(1:3, function(x) x^2))

# Лучше всего использовать lapply и sapply, если это имеет смысл для ваших данных и ожидаемого результата.
# Если вы хотите получить список, примените lapply. Если вектор — sapply.

#### Обходные пути ####
# В любом случае, простой способ — передать sapply вектор индексов и написать свою функцию, делая 
# предположение о структуре входных данных. Давайте еще раз взглянем на пример с mean:
sapply(1:3, function(x) mean(m[,x]))
# [1] -0.02664418  1.95812458  4.86857792

# В нашу функцию мы передаем индексы колонок (1, 2, 3), что предполагает наличие переменной m с нашими данными. 
# Хорошо как быстрое решение, но в целом не очень, и с большой вероятностью в дальнейшем превратится в большую 
# проблему при поддержке.

# Можно сделать немножко лучше, передавая наши данные как аргумент функции и используя специальный аргумент "...", 
# который принимают все функции apply для передачи дополнительных параметров:
sapply(1:3, function(x, y) mean(y[,x]), y=m)

#[1] -0.02664418  1.95812458  4.86857792

# На этот раз у нашей функции два аргумента, х и у. Переменная х, как и раньше, будет обозначать данные, 
# которые перебирает sapply, что бы это ни было. Переменную у мы передадим, используя необязательные аргументы sapply.
# В этом случае мы передали на вход m, явно задавая переменную у при вызове sapply. Это не строго обязательно, 
# но легче для восприятия и поддержки кода. Значение у будет одинаково при каждом вызове нашей функции в sapply.
# Настоятельно не рекомендуется передавать индексированные аргументы таким образом, это источник ошибок и 
# трудно воспринимается, когда другие люди будут читать ваш код.



























