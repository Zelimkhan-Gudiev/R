remove(list = ls())


#### Contents ####
# Данный урок будет посвящен базовым понятиям, необходимым для работы в R.
# Мы научимся создавать переменные различных типов и работать с ними.
# Скрипт первого урока вы можете скачать по ссылке
# https://stepik.org/media/attachments/course/129/Variables.R


#### Step 2 of 16: Variable assiment ####

my_var1  <- 42 # создаем переменные
my_var2  <- 35.25 # создаем переменные

# с переменными можно работать
my_var1 + 100 # 42 + 100 = 142
my_var1 + my_var2 - 12 # 42 + 35.25 = 65.25 
my_var3  <- my_var1^2 + my_var2^2 # 42^2 + 35.25^2 = 3006.562


#### Step 3: Logical operations ####

my_var3 > 200 # Правда ли, что my_var3 (3006.562) больше чем 200? Ответ: TRUE
my_var3 > 3009 # Правда ли, что my_var3 (3006.562) больше чем 200? Ответ: FALSE
my_var1 == my_var2 # Правда ли, что my_var1 (42) равна my_var2 (35.25)? Ответ: FALSE
my_var1 != my_var2 # Правда ли, что my_var1 (42) НЕ равна my_var2 (35.25)? Ответ: TRUE
my_var3 >= 200 # Правда ли, что my_var3 (3006.562) больше или равна 200? Ответ: TRUE
my_var3 <= 200 # Правда ли, что my_var3 (3006.562) меньше или равна 200? Ответ: FALSE

my_new_var  <- my_var1 == my_var2 # результат выполенения логических операций можно сохранять в переменные

#### Приммечание == ####
# знак ==  используется для сравнения. 1 == 2 Ответ: нет
# знак = используется для присвоения. а = 2 Результат в переменной а сохрарено число 2 


#### Step 7 of 16. Задача #### 
# В уже созданных переменных number_1, number_2 и number_3, сохранены целые числа. 
# Проверьте, действительно ли сумма первых двух чисел строго больше, чем третье число. 
# Результат сравнения (TRUE или FALSE) сохраните в новую переменную с именем result.

sum_1_2 <- number_1 + number_2 # Переменные number_1, number_2, number_3 уже созданы в невидимой для вас части кода!:)
result <- sum_1_2 > number_3

#### Step 6, 7, 10, 11: Vectors ####

1 : 67 # создаем вектор (последовательность чисел)
my_vector1  <- 1:67 # создаем переменную и сохраняем в нее вектор (последовательность чисел)
my_vector2  <- c(-32, 45, 67, 12.78, 129, 0, -65) # если хотим сами указать числа последовательности, то испольуем ф. "c" (Combine)
?c  # Combine Values into a Vector or List

#### Step 9 of 16. Обращение к элементам вектора ####

my_vector1[1] # чему равняется первый элемент вектора my_vector1
my_vector1[3] # чему равняется третий элемент вектора my_vector1
my_vector2[2] # чему равняется второй элемент вектора my_vector2

my_vector2[c(1,2,3)] # выводим 1, 2 и 3 элемент my_vector2. Чтобы обратиться к нескольким элементам нужно в индексе указывать вектор [c(1,2,3)]
my_vector2[1:3] # выводим 1, 2 и 3 элемент my_vector2. Чтобы обратиться к нескольким элементам нужно в индексе указывать вектор [1:3]
my_vector2[c(1,5,6,7,10)] # выводим 1,5,6,7,10 элемент my_vector2. 10 - NA


#### Step 10 of 16. Обращение к элементам вектора ####
# При помощи функции с() мы можем объединять не только несколько чисел, но сразу несколько векторов. Например:
  vector_1 <- c(1,2,3)
  vector_2 <- c(4,5,6)
  vector_3 <- c(vector_1, vector_2)
# Данная операция называется конкатенацией векторов. В результате vector_3 будет содержать последовательность чисел от 1 до 6.

# Создайте переменную the_best_vector, в которой хранятся числа от 1 до 5000 и затем числа от 7000 до 10000.
  # v1
  vector_1 <- c(1:5000)
  vector_2 <- c(7000:10000)
  the_best_vector <- c(vector_1, vector_2)
  # v2
  the_best_vector <- c(1:5000, 7000:10000)

  
  
#### Step 11 of 16. Задача. Обращение к элементам вектора ####
# В уже созданной переменной my_numbers сохранен вектор из 20 целых чисел. 
# Ваша задача создать новую переменную my_numbers_2, в которой будет сохранен 
# 2, 5, 7, 9, 12, 16 и 20 элемент вектора my_numbers.
  
  my_numbers_2 <- my_numbers[c(2, 5, 7, 9, 12, 16 и 20)]
  
  
#### Step 12 of 16. Обращение к элементам с помощью логических операций ####
  my_vector1 + 10 # с векторами можно выполнять арифметические операции.
  my_vector2 + 56 # арифметическая операция выполняется с каждым элементом вектора. Получаем новый вектор (в консоле), 
  # элементы которого это результат выполления арифметической операции над каждым элементом исходного вектора
  


  my_vector2 == 0 # с векторами можно выполнять логичекие операции
  my_vector1 > 30 # логичекая операция выполняется с каждым элементом вектора. Получаем новый вектор (в консоле), 
  # элементы которого это результат выполления логической операции над каждым элементом исходного вектора

  # Можно полностью уйти от числ и использовать вместо них переменные 
x  <- 23
my_vector1 > x # сравниваеи 23 с my_vector1 <- vector_1 <- c(1:5000). Получаем новый логический вектор
x == 23 # сравниваеи x == 23. Ответ TRUE.

# Таким образом, при выполнении опреций с векторами, такие операции выполняются в отношении каждого 
# элемента вектора и на выход получаем новый вектор. Понимание данного принципа важно для понимания процесса обращения к элементам вектора.
# Мы можем обращаться к элементам, которые отвечают определенным условиям (соответствую вектору указанному в индексе)


#### Step 13 of 16. Обращение к элементам с помощью логических операций ####
my_vector2 > 0 # обратимся только ко всем элементам исх вектора, которые больше 0. Получаем новый вектор
my_vector2[my_vector2 > 0] # новый вектор используем для индексации, т.е. используем один вектор для обращания к элементам другого вектора
my_vector2[my_vector2 < 0] # берем вектор из отрицательных элементов my_vector2 и обращаемся с помощь него к my_vector2. 
    # Результат получаем новый вектор, который состоит из отрицательных элементов my_vector2
my_vector2[my_vector2 == 0]

# к элеменам вектора можно обращаться с использованием сложных условий
my_vector1[my_vector1 > 20 & my_vector1 < 30]
my_numbers  <- my_vector1[my_vector1 > 20 & my_vector1 < 30]
positive_numbers  <- my_vector2[my_vector2 > 0]

# пример
v1  <- c(165, 178, 180, 181, 167, 178, 187, 167, 187) # сохраним данные в перемменную v1
mean_v1  <- mean(v1) # сохраним в переменную mean_v1 ср. ариф всех значений перемменной v1
v1[v1 > mean_v1] # создан новый логический вектор, который является резлтатом логичекой операции к исх. вектору v1. 
greater_than_mean  <- v1[v1 > mean_v1] #  новый логический вектор, сохранен в новую переменную greater_than_mean 


#### Step 14 of 16. Задача ####
# В уже созданной переменной my_vector хранится вектор из 20 целых чисел.
# Найдите сумму всех элементов вектора , которые больше 10. Сохраните сумму в переменную my_sum.
  sum(x) # сумма элементов числового вектора x

greater_than_10 <- my_vector[my_vector > 10]
my_sum <- sum(greater_than_10)



#### Step 15 of 16. Lists and dataframes ####
# В векторе можно сохранять только данные одного типа
# Lists можно сохранять разные вектора с разным типом данных
  # data[[1]][1] индексация: в [[]] указывается уровень (вектор), в [] указывается элемент вектора указанного в '[[]]'

# Dataframes - таблица
# ф. dat data.frame

is_maried  <- c(F, F, T, T)
name  <- c("Olga", "Maria", "Nastya", "Polina")
age  <- c(16, 18, 22, 27)
my_data  <- data.frame(Name = name, Age = age, Status = is_maried)

typeof(my_data) # list, т.к. данный дф содержит данные разного типа


#### Step 16 of 16. Задача ####
# В векторе  my_vector отберите только те наблюдения, которые отклоняются от среднего меньше 
# чем на одно стандартное отклонение. Сохраните эти наблюдения в новую переменную my_vector_2. 
# При этом исходный вектор my_vector оставьте без изменений.
  mean(x) # среднее значение вектора x
  sd(x) # стандартное отклонение вектора x
# также может пригодиться:
  abs(n) # абсолютное значение числа n 

  my_vector_2 <- my_vector[my_vector < mean(my_vector) + sd(my_vector) & my_vector > mean(my_vector) - sd(my_vector)]

