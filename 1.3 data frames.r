remove(list = ls())

#### Памятка ___________________________________________________________________________________________________________________________________####
# В курсе мы часто будем использовать следующие арифметические и логические операции:

### Арифметические операции ###

# + сложение
# - вычитание
# * умножение
# / деление  (5 / 2 = 2.5)
# ^ или **  возведение в степень (5^2 = 25 или 5**2 = 25)
# x %% y остаток от деления  (5 %% 2 = 1)
# x %/% y целая часть от деления (5 %/% 2 = 2)

### Логические операции ###

# < меньше 
# <= меньше или равно
# > больше
# >= больше или равно
# == проверка на равенство
# != не равно
# !x не x
# x | y x или y
# x & y x и y

# TRUE  можно сокращенно обозначать T
# FALSE можно сокращенно обозначать F


#### Contens __________________________________________________________________________________________________________________________________ ####

# Этот урок посвящён работе с data frame. Вначале мы посмотрим, как загружать готовые датасеты в R 
# с помощью функции read.table (read.csv). Чтобы функция сработала, убедитесь, что: 
# 1) указано расширение загружаемого файла
# 2) название файла взято в кавычки
# 3) загружаемый файл находится в рабочей директории. 

# Если файл находится не в рабочей директории, есть три способа решить эту проблему: 
# 1) изменить рабочую директорию (в RStudio: Session -> Set Working Directory -> Choose Directory...)
# 2) переместить файл в актуальную рабочую директорию
# 3) указать полный путь к файлу, например: read.csv("C:/Users/username/documents/evals.csv")

# Скрипт для урока можно скачать по ссылке: https://stepic.org/media/attachments/lesson/11481/data%20frames.R.
# Датасет, с которым мы будем работать: https://stepic.org/media/attachments/lesson/11481/evals.csv.


#### Reading data _____________________________________________________________________________________________________________________________ ####

?read.table()
?read.csv

my_data <- read.csv('https://stepik.org/media/attachments/lesson/11481/evals.csv')
yt <- read.csv2("yt.csv")


####  Summaries _______________________________________________________________________________________________________________________________ #### 

head(my_data) # комманда head по умолчанию выводит шесть первых строк
head(my_data, 7) # через запятую можно указать сколько строк выводить

tail(my_data) # комманда tail по умолчанию выводит шесть последних строк
tail(my_data, 7) # через запятую можно указать сколько строк выводить

View(my_data) # функция View позволяет увидеть 1000 наблюдений (строк)
str(my_data) # показывает внутреннюю структуру объекта R
summary(my_data) # показывает некоторые сводные данные (описательные статистики для кол. переменных) дата фрейма
names(my_data) # показывает наименования переменных (возвращает вектор значений из наименования переменных)

a <- names(my_data)

####  yt (Summaries) __________________________________________________________________________________________________________________________ ####


names(yt)
head(yt)
summary(yt)
summary(yt$duration, yt$numb_ret_depir, yt$numb_ret_oiv) # error. I can't output summary for duration, numb_ret_depir, numb_ret_oiv


#### Variables (Обращение к переменным) ________________________________________________________________________________________________________####

my_data$score # выводит вектор значений переменной score
b <- my_data$score # вектор значений можно присвоить объектьу b

mean(my_data$score) # т.к. переменная в дата фрейме является вектром, то с данной переменной можно выполнять все операции доступные для векторов, например, расчитать ср. значение
summary(my_data$score) # можно применить функцию саммари для расчета описательных статистик

my_data$score*2 # можно выполнять арифметические операции


# можно создовать новые переменные

my_data$ten_point_scale <- my_data$score*2 # Если после знака $ указать не существующую переменную,
# то она будет создана. 

summary(my_data$ten_point_scale)

my_data$new_variable <- 0 # создадим новую переменную, все значения которой содержат нули
my_data$number <- 1:nrow(my_data) # создадим новую переменную, содержащую порядкоый номер строки (наблюдения). Номер строки задается вектором значений "1:nrow(my_data)" от "1" до количество количества строк в my_data 
summary(my_data$number)
nrow(my_data) # возвращает количество строк в дата фрейме
ncol(my_data) # возвращает количество столбцов в дата фрейме


#### yt (Variables (Обращение к переменным)) ___________________________________________________________________________________________________####

yt$teamleader


#### Subsetting (обращение к конкретным кусочкам данных с помощью индекса) ____________________________________________________________________ ####

my_data$score[1:10] # обращение к первым десяти значениям переменной (вектора) my_data$score с помошью индекс [ ]
# индексы [ ] можно задавать разными способоми. В индексе [ ] можно указывать вектор или логическое значение и т.д.
my_data[1,1] # т.к. дата фрейм является двумерным объектом, то можно обратиться к любому его элементу указав два индекса.
my_data[c(2,193,225),1] # в идексе до запятой указываются строки, а после запятой столбцы 
my_data[101:200,1]

my_data[5,] # если не указать индекс переменной, то это значит, что для нам не важен и мы хотим посмотреть значения всех переменных. С помощью данной строки мы обращаемся к пятой строке нашего дата фрейма со всеми столбцами.  
my_data[,1] # можн обратиться к первому стобцу. В таком случае мы увидим все значения первой переменной (столбца). Вектор "my_data[,1]" полностью повторяет значения my_data$score
my_data[,1] == my_data$score # Вектор "my_data[,1]" полностью повторяет значения my_data$score

my_data[,2:5] # Также как и строки можно вызывать столбцы
View(my_data[,2:5])
View(head(my_data[,2:5]))


#### yt (Subsetting (обращение к конкретным кусочкам данных с помощью индекса)) _______________________________________________________________ ####





####  Subsetting with condition (обращение к конкретным кусочкам данных, которые отвечают условиям) ___________________________________________ #### 

my_data$gender # обратимя к переменной my_data$gender
my_data$gender == 'female' # проверим каким строкам (наблюдений) соответствуют значение 'female'. Комманда my_data$gender на выходе дает логический вектор из FALSE и TRUE

# попрубуем использовать данные знания для обращения к конкретным значениям дата фрейма
my_data[,1] # если мы выполним данную комманду мы получим все значения первого столбца, т.к. мы пропустили индекс строки
# но мы можем использовать логический вектор для обращения к части данных
my_data[my_data$gender =='female', 1] # если в качестве индекса строки указать логиический вектор, то мы получим только те значения первого столбца, значения строк которых отвечает требованиям my_data$gender =='female'
my_data[my_data$gender == 'female', 1:3] # можно обращаться к любому количеству столбцов, например к первым трем стобцам
View(my_data[my_data$gender == 'female', c(1:3)])
head(my_data[my_data$gender == 'female', 1:3])


# В R есть функция, которая позволяет нам обращается к .. данным без индексации
subset(my_data, gender == 'female') # в качестве условия указана факторная перменная gender
View(subset(my_data, gender == 'female'))
head(subset(my_data, gender == 'female'))

subset(my_data, score > 3.5) # в качестве условия указана количественная перменная score 
View(subset(my_data, score > 3.5))
head(subset(my_data, score > 3.5))

subset(my_data, score < 3.5)
View(subset(my_data, score < 3.5))
head(subset(my_data, score < 3.5))

subset(my_data, score == 3.5)
View(subset(my_data, score == 3.5))
head(subset(my_data, score = 3.5))



#### rbind, cbind (rowbind - соединение по строкам, columnbind - соединение по столбцам) _____________________________________________________ ####
# rbind (rowbind) - соединяет два дата фрейма по строкам
# для демонтрации того, что делает функция rbind создадим два дата фрейма my_data2, my_data3
my_data2 <- subset(my_data, gender == 'female') # дата фрейм my_data2 будет содержать только те наблюдения где преподователь женщина
my_data3 <- subset(my_data, gender == 'male') # дата фрейм my_data3 будет содержать только те наблюдения где преподователь мужчина
my_data4 <- rbind(my_data2, my_data3) # rbind соединяет два дата фрейма с одиновым количеством столбцов (наименования столбцов должны совпадать)
# my_data4 отличается от my_data только порядком строк: в my_data4 сначала идут стоки где gender == 'female', а затем стоки где gender == 'male'

# cbind (columnbind) - соединяет два дата фрейма по столбцам
# для демонтрации того, что делает функция rbind создадим два дата фрейма my_data5, my_data6
my_data5 <- my_data[, 1:10] # создадим дата фрейм my_data5, в котором будут все строки, но столбцы только с 1 по 10
my_data6 <- my_data[, 11:24] # создадим дата фрейм my_data6, в котором будут все строки, но столбцы только с 1 по 24
my_data7 <- cbind(my_data5, my_data6) # cbind соединяет два дата фрейма по столбцам 



#### Step 6 of 11 _____________________________________________________________________________________________________________________________ ####
# Когда вы запускаете R, автоматически загружаются основные библиотеки для работы. 
# В их числе библиотека datasets, в которой хранятся наборы данных из разных исследований. 
# Чтобы просмотреть весь список доступных датасетов, выполните команду library(help = "datasets"). 
# Некоторые из этих датасетов мы будем использовать в наших задачах. Они доступны по имени в любой момент работы. 
# Например, если вы захотите использовать датасет mtcars, можете просто выполнить команду mtcars, чтобы увидеть данные в консоли.
# Команда data(mtcars) добавит датасет в рабочую среду. Команда help(mtcars) выведет информацию о датасете.
# Команда my_data <- mtcars запишет датасет в новую переменную.

library(help = 'datasets') # Чтобы просмотреть весь список доступных датасетов, выполните команду library(help = "datasets")
mtcars # Команда mtcars выводит данные в консоли
data(mtcars) # Команда data(mtcars) добавит датасет в рабочую среду
help(mtcars) # Команда help(mtcars) выведет информацию о датасете (?mtcars)
mydata <- mtcars # Команда my_data <- mtcars запишет датасет в новую переменную




#### Step 7 of 11 _____________________________________________________________________________________________________________________________ ####
# В этой задче поработаем со встроенными данными mtcars. В датафрэйме mtcars создайте новую колонку (переменную) 
# под названием even_gear, в которой будут единицы, если значение переменной (gear) четное, и нули если количество нечетное.   
# Подсказка: вам может помочь оператор деления с остатком:5 %% 2 == 1 TRUE
# Решения
# Вариант 1
mtcars$even_gear <- ifelse (mtcars$gear %% 2 == 1, 0, 1) # если остаток деления значения переменной mtcars$gear на 2 равно 1, то запиши в mtcars$even_gear значение 0, если нет то запиши значение 1

# Варинат 2
mtcars$even_gear1 <- (mtcars$gear+1) %% 2 

# Вариант 3
mtcars$even_gear2[mtcars$gear%%2 == 0] <- 1 # если остаток деления значения переменной mtcars$gear на 2 равно 0, то запиши в mtcars$even_gear2 значение 1
mtcars$even_gear2[mtcars$gear%%2 == 1] <- 0 # если остаток деления значения переменной mtcars$gear на 2 равно 1, то запиши в mtcars$even_gear2 значение 0

# Вариант 4
data('mtcars')
a <- mtcars$gear # создадим переменную a и запишем в нее значения перменной mtcars$gear
even <- subset(mtcars, a%%2 == 0) # создадим дата фрейм even и сохраним в нем сабсет данных, значения переменной a <- mtcars$gear отвечает условию: остаток деления а на 2 равен 0 (a%%2 == 0), т.е. четные значения
even$even_gear <- 1 # создадим в днном дата фрейме новую переменную even$even_gear и запишим в нее значение 1

uneven <- subset(mtcars, a%%2 == 1)  # создадим дата фрейм uneven и сохраним в нем сабсет данных, значения переменной a <- mtcars$gear отвечает условию: остаток деления а на 2 равен 1 (a%%2 == 1), т.е. нечетные значения
uneven$even_gear <- 0 # создадим в днном дата фрейме новую переменную even$even_gear и запишим в нее значение 0

mtcars <- rbind(even, uneven) # соединим два дата фрема по строкам




#### Step 8 из 11 _____________________________________________________________________________________________________________________________ ####
# Вариант 1
mpg_4.1 <- mtcars$mpg[mtcars$cyl == 4]

# Вариант 2
s <-subset(mtcars, cyl==4)
mpg_4.2 <- s$mpg

# Вариант 3
mpg_4 <- mtcars[mtcars$cyl == 4, "mpg"]




#### Step 9 of 11 _____________________________________________________________________________________________________________________________ ####
# Продолжим нашу работу с данными mtcars. Теперь ваша задача создать переменную - вектор mpg_4 и 
# сохранить в нее значения расхода топлива (mpg) для машин с четырьмя цилиндрами (cyl). 
# Вариант 1
mpg_4 <- mtcars[mtcars$cyl == 4, "mpg"]
# Вариант 2
mpg_4 <- mtcars$mpg[mtcars$cyl == 4]
# Вариант 3
mpg_4 <- subset(mtcars, cyl == 4)$mpg
# Вариант 4
mpg_4 <- subset (mtcars$mpg, mtcars$cyl == '4')
# Вариант 5
mpg_4 <-mtcars[mtcars$cyl == '4', 1]
# Вариант 6
s <-subset(mtcars, cyl == 4)
mpg_4 <- s$mpg

#### Step 10 of 11 ####
# А теперь научимся отбирать только некоторые строчки из исходных данных. 
# Ваша задача создать новый dataframe под названием mini_mtcars, в котором будут сохранены только 
# третья, седьмая, десятая, двенадцатая и последняя строчка датафрейма mtcars.

# Вариант 1
mini_mtcars <- mtcars[c(3,7,10,12,32),]

# Вариант 2
mini_mtcars <- mtcars[c(3, 7, 10, 12, nrow(mtcars)), ]

# Вариант 3
mydata <- mtcars
s3 <- subset(mydata[3,])
s7 <- subset(mydata[7,])
s10 <- subset(mydata[10,])
s12 <- subset(mydata[12,])
s32 <- subset(mydata[nrow(mydata),])
mini_mtcars1 <- rbind(s3, s7, s10, s12, s32)



#### Step 11 из 11 ____________________________________________________________________________________________________________________________ ####
# Укажите какая команда создаст сабсет данных mtcars, только для тех автомобилей, 
# у которых число цилиндров (cyl) не равняется 3, и время разгона автомобиля (qsec) больше среднего по выборке.
new_data <- subset(mtcars, cyl !=3 & qsec > mean(qsec))





#### Шпоры ____________________________________________________________________________________________________________________________________ ####
# 1. Чтобы изучить структуру данных воспользуйтесь командой str()
# str(mtcars)
# 2. Чтобы отобрать нужные колонки (переменные) в данных вы можете:
# - использовать номера колонок (не забудьте обернуть индексы в вектор):
# mtcars[, c(1, 3, 4)] 
# - использовать имена колонок:
# mtcars[, c("mpg", "hp")]
# 3. Чтобы отобрать нужные строки в данных:
# mtcars[c(1, 5, 7), ]
# Эти приемы можно комбинировать:
# mtcars[c(1, 4, 5), c(1, 4)]
# Запомните, сначала идут индексы строк, потом индексы колонок! Также обратите внимание, 
# что мы можем использовать отрицательную индексацию, чтобы отобрать все колонки/строки кроме указанных:
# mtcars[, -c(3, 4)] # отберем все строчки и все колонки кроме 3 и 4. 
# 4. Для более сложных запросов используйте функцию subset():
# subset(mtcars, hp > 100 & am == 1)
# 5. Добавить новую переменную можно при помощи оператора $
# mtcars$new_var <- 1:32
# 6. Чтобы удалить переменную из данных, используйте такую конструкцию:
# mtcars$new_var <- NULL

