---
title: "Basics of statistics 2 (1.9)"
author: "Zelimkhan"
date: '2023-03-12'
output: html_document
---

# Exircise 1 of 9
Практические задания по анализу данных в R 
https://stepik.org/lesson/26186/step/1?unit=8128

# Exircise 2 of 9
# Напишите функцию NA_position, которая получает на вход два числовых вектора одинаковой длины. 
# Функция должна возвращать TRUE, если позиции NA в обоих векторах совпадают или пропущенных значений вообще нет, 
# и значение FALSE, если позиции NA в векторах не совпадают.  

```{r}
NA_position  <- function(x, y){
  all(is.na(x) == is.na(y))
}
```
Проверка
```{r}
v1  <- c(1, 2, 3)
v2  <- c(3, 4, 6)
NA_position(v1, v2)
```

```{r}
v1  <- c(1, 2, NA)
v2  <- c(3, 4, NA)
NA_position(v1, v2)
```

```{r}
v1  <- c(NA, 2, NA)
v2  <- c(3, 4, NA)
NA_position(v1, v2)
```

# Exircise 3 of 9
Напишите функцию smart_test, которая получает на вход dataframe с двумя номинативными переменными с произвольным числом градаций. Функция должна проверять гипотезу о независимости этих двух переменных при помощи критерия хи - квадрат или точного критерия Фишера.

Если хотя бы в одной ячейке таблицы сопряженности двух переменных меньше 5 наблюдений, функция должна рассчитывать точный критерий Фишера и возвращать вектор из одного элемента: получившегося p - уровня значимости.

Если наблюдений достаточно для расчета хи-квадрат (во всех ячейках больше либо равно 5 наблюдений), тогда функция должна применять критерий хи-квадрат и возвращать вектор из трех элементов: значение хи-квадрат, число степеней свободы,  p-уровня значимости.
```{r}
x <- mtcars[,c("am", "vs")]
```

```{r}
smart_test <- function(x) {
  x1 <- table(x)
  if(any(x1 < 5)) {
    fish <- fisher.test(x1)
    fish$p.value
  } else {
    chis <- chisq.test(x1)
    unlist(c(chis$statistic, chis$parameter, chis$p.value))
  }
}
```
Проверка
```{r}
smart_test(x)
```

# Exircise 4 of 9
Почувствуй себя биоинформатиком! Вся наследственная информация в живых организмах хранится внутри молекулы ДНК. Эта молекула состоит из последовательности четырех "букв" — A, T, G и C. 

Напишите функцию most_significant, которая получает на вход dataframe с произвольным количеством переменных, где каждая переменная это нуклеотидная последовательность. 

Cкачайте тестовый набор данных (смотри ниже), чтобы познакомиться с их структурой, на которых будет тестироваться ваша функция. Рассмотрим пример, всего-лишь с несколькими наблюдениями, чтобы прояснить суть задачи:
   V1 V2 V3
1  A  A  C
2  G  G  A
3  C  C  C
4  T  T  A
5  G  T  T
6  T  A  G

В этом примере три последовательности  V1 , V2, V3. 
Для каждой переменной мы можем проверить нулевую гипотезу о том, что все нуклеотиды (A, T, G, C) встречаются равновероятно внутри этой последовательности. Однако, возможно, что в некоторых последовательностях распределение частоты встречаемости каждого нуклеотида отличается от равномерного.

Функция должна возвращать вектор с названием переменной (или переменных), в которой был получен минимальный p - уровень значимости при проверке гипотезы о равномерном распределении нуклеотидов при помощи критерия хи - квадрат.

```{r}
test_data <- read.csv("https://stepic.org/media/attachments/course/524/test_data.csv", stringsAsFactors = F)
```
str(test_data)
'data.frame':  30 obs. of  3 variables:
 $ V1: chr  "C" "G" "C" "T" ...
 $ V2: chr  "A" "G" "C" "T" ...
 $ V3: chr  "C" "A" "C" "A" ...
 
most_significant(test_data)
[1] "V3" 
обратите внимание,функция возвращает строку с названием
в этом примере ответ - одна переменная, но может быть и несколько

Подсказки:
1. К именам переменных легко обратиться при помощи функции colnames().
2. Вам может пригодится функция which().

```{r}
most_significant <- function(x){
  p_val <- sapply(test_data, function(x) chisq.test(table(x))$p.value)
  p_val_min <- p_val[p_val == min(p_val)]
  names(p_val_min)
}


```
Cheking
```{r}
most_significant(test_data)
```
v2
```{r}

x <- test_data
most_significant <- function(x){
  contingency_cols <- sapply(x, table)
  chisq_for_cols <- apply(contingency_cols, 2, chisq.test)
  p_values <- sapply(chisq_for_cols, "[", 3)
  return(colnames(x[which(p_values == min(unlist(p_values)))]))
}
```
v3
```{r}
most_significant <- function(df) {
  result <- sapply(df, function(x) chisq.test(table(x))$p.value)
  names(result)[result == min(result)]
}
```
v4
```{r}
most_significant  <- function(test_data){    
	chisq_tests <- sapply(test_data, function(col) chisq.test(table(col))$p.value)    
	min_p  <- which(chisq_tests == min(chisq_tests))    
	return(colnames(test_data)[min_p])
}
```
v5
```{r}
most_significant <-  function(x){
  # в t сохраняем вектор из p-значений по столбцам
  t <- sapply(x, function (y) chisq.test(table(y))$p.value)
  # возвращаем имена тех векторов, которые соответствуют минимальному значению, даже если их несколько
  return(names(which(t == min(t))))
}
```
v6
```{r}
most_significant <-  function(x){
  x_factor <-apply(x, 2, factor)
  x_table <- apply(x_factor, 2, table)
  p_value <- apply(x_table, 2, function(x_table) chisq.test(x_table)$p.value)
  return(names(p_value[p_value==min(p_value)]))
}
```

# Exircise 5 of 9
В лекциях я говорил, что иногда возникает необходимость перекодировать количественную переменную в номинативную. Однако зачастую мы можем создавать новую номинативную переменную, комбинируя значения нескольких количественных переменных. Рассмотрим такой пример.

Воспользуемся встроенными в R данными Iris. Они сразу доступны для работы. Если вы не знакомы с историей этого набора данных, вызовите справку: ?iris 
Создайте новую переменную important_cases - фактор с двумя градациями ("No" и "Yes"). Переменная должна принимать значение Yes, если для данного цветка значения хотя бы трех количественных переменных выше среднего. В противном случае переменная important_cases  будет принимать значение No.

Например, рассмотрим первую строчку данных iris:
  Sepal.Length Sepal.Width Petal.Length Petal.Width Species
1          5.1         3.5          1.4         0.2  setosa

В данном случае только значение  Sepal.Width 3.5 больше, чем среднее значение mean(Sepal.Width) = 3.057. Соответственно для первого цветка значение переменной important_cases будет "No".

Теперь рассмотрим 62 строчку данных
   Sepal.Length Sepal.Width Petal.Length Petal.Width    Species
62          5.9           3          4.2         1.5 versicolor


В данном случае и значение Sepal.Length 5.9 больше чем среднее по выборке, mean(Sepal.Length)  = 5.84. Также значение Petal.Length и Petal.Width для этого цветка больше чем соответствующие средние значения: mean(Petal.Length) = 3.76,   mean(Petal.Width ) = 1.1.  Следовательно, для этого цветка значение переменной important_cases будет "Yes".
Таким образом, если хотя бы три переменные превышают среднее значение по выборке, тогда  значение переменной important_cases будет "Yes".

Что должно получиться:
str(iris$important_cases)
 Factor w/ 2 levels "No","Yes": 1 1 1 1 1 1 1 1 1 1 ...

table(iris$important_cases)
 No Yes 
 81  69 
Формат ответа: в поле для ответа напишите скрипт, который создает новую переменную - фактор в данных iris. Код для проверки задания считает переменную  important_cases из данных Iris и сравнит ее с верным ответом.
```{r}
x1 <- apply(iris[, 1:4], 2, function(x) 
                            ifelse(x >= mean(x, na.rm = T), 1, 0))
iris$important_cases <- as.factor(apply(x1, 1, function(x)
                                      ifelse(sum(x) >= 3, "Yes", "No")))
```
v2
```{r}
importance_calc <- function(v1, v2, threshold=3){    
	ifelse(sum(v1 > v2) >= threshold, 'Yes', 'No')}    
iris$important_cases <- factor(apply(iris[1:4], 1, importance_calc, v2 = colMeans(iris[, 1:4])))
```
v3
```{r}
means <- lapply(iris[-5], mean)
iris$important_cases <- as.factor(ifelse(rowSums(iris[-5] > means) > 2, 'Yes', 'No'))
```
v4
```{r}
iris$important_cases <- as.factor(ifelse((iris$Sepal.Length > mean(iris$Sepal.Length)) + 
                                         (iris$Sepal.Width > mean(iris$Sepal.Width)) + 
                                         (iris$Petal.Length > mean(iris$Petal.Length)) + 
                                         (iris$Petal.Width > mean(iris$Petal.Width)) >= 3, "Yes", "No"))
```
v5
```{r}
num_cols <- sapply(iris, is.numeric)
means <- colMeans(iris[num_cols])
res <- sweep(iris[num_cols], 2L, means, ">")
iris$important_cases <- factor(rowSums(res) >= 3, levels = c(FALSE, TRUE), labels = c("No", "Yes"))
```
v6
```{r}
library(dplyr)
ir <- iris %>% 
  select(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width) %>% 
  sapply(function(x) x > mean(x)) %>% 
  rowSums()
iris$important_cases <- factor(ifelse(ir > 2, 'Yes', 'No'))
```

# Exircise 6 of 9
Обобщим предыдущую задачу! Напишем функцию get_important_cases, которая принимает на вход dataframe с произвольным числом количественных переменных (гарантируется хотя бы две переменные). Функция должна возвращать dataframe с новой переменной - фактором important_cases.

Переменная  important_cases принимает значение Yes, если для данного наблюдения больше половины количественных переменных имеют значения больше среднего. В противном случае переменная important_cases принимает значение No.

Переменная  important_cases - фактор с двумя уровнями 0 - "No", 1  - "Yes".  То есть даже если в каком-то из тестов все наблюдения получили значения "No", фактор должен иметь две градации. 

Я написал об этой важной особенности факторов в небольшой памятке. 

Пример работы функции. 
```{r}
test_data <- data.frame(V1 = c(16, 21, 18), 
                        V2 = c(17, 7, 16), 
                        V3 = c(25, 23, 27), 
                        V4 = c(20, 22, 18), 
                        V5 = c(16, 17, 19))
```
get_important_cases(test_data)
  V1 V2 V3 V4 V5 important_cases
1 16 17 25 20 16              No
2 21  7 23 22 17              No
3 18 16 27 18 19             Yes

```{r}
x <- iris[, 1:4]
get_important_cases <- function(x) {
  means <- sapply(x, function(x) x > mean(x))
  rs <- rowSums(means)
  x$important_cases <- factor(rs > floor(ncol(x)/2), levels = c(FALSE, TRUE), labels = c("No", "Yes"))
  return(x)
}

```
Cheking
```{r}
get_important_cases(x)
```

# Exircise 7 of 9
Задачка на программирование.

В R мы без труда можем рассчитать среднее и медиану вектора, а вот встроенной функции для расчета моды — наиболее часто встречаемого значения — в R нет! А мода так бы пригодилась нам при анализе номинативных данных! При этом функция mode в R существует, но выполняет абсолютно другую задачу (если хотите узнать, какую именно, ознакомьтесь со справкой: наберите в консоли ?mode).

Напишите функцию stat_mode, которая получает на вход вектор из чисел произвольной длины и возвращает числовой вектор с наиболее часто встречаемым значением. Если наиболее часто встречаемых значений несколько, функция должна возвращать несколько значений моды  в виде числового вектора. 
```{r}
v <- c(1, 2, 3, 3, 3, 4, 5)
stat_mode(v)
```
[1] 3
```{r}
v <- c(1, 1, 1, 2, 3, 3, 3)
stat_mode(v)
```
[1] 1 3
```{r}
stat_mode <- function(x) {
t <- table(v)
moda <- names(t)[t == max(t)]
return(as.integer(moda))
}
```
v2
```{r}
stat_mode <- function(v){        
	mode_positions <- which(table(v) == max(table(v)))    
	as.numeric(names(table(v))[mode_positions])
}
```
v3
```{r}
stat_mode <- function(x) { 
  as.numeric(names(table(x)[table(x) == max(table(x))])) 
  } 
```

v4
```{r}
stat_mode <- function(x) {
  t <- tabulate(x)
  y <- which(t == max(t))
}
```


# Exircise 8 of 9
Доктор Пилюлькин решил вооружиться статистикой, чтобы сравнить эффективность трех лекарств! Давайте поможем ему и напишем функцию max_resid, которая получает на вход dataframe с двумя переменными: типом лекарства и результатом его применения. 
Drugs - фактор с тремя градациями: drug_1, drug_2, drug_3.     
Result - фактор с двумя градациями: positive, negative.
Функция должна находить ячейку таблицы сопряженности с максимальным  значением стандартизированного остатка и возвращать вектор из двух элементов: название строчки и столбца этой ячейки.
Для расчета стандартизированных остатков вы можете воспользоваться уже знакомой вам функцией chisq.test(). Изучите справку по этой функции, чтобы найти, где хранятся стандартизированные остатки.
Пример работы функции на одном из вариантов:
```{r}
test_data <- read.csv("https://stepic.org/media/attachments/course/524/test_drugs.csv", stringsAsFactors = T)
str(test_data)
```
'data.frame':  395 obs. of  2 variables:
$ Drugs : Factor w/ 3 levels "drug_1","drug_2",..: 3 1 1 2 1 1 3 1 2 3 ...
$ Result: Factor w/ 2 levels "negative","positive": 2 1 1 2 1 2 2 2 1 1 ...
```{r}
max_resid(test_data)
```
[1] "drug_1"   "positive"
именно в этой ячейке было максимальное значение стандартизированного остатка, равное 2.07

```{r}
t <- table(test_data)

max_resid <- function(x) {
  t <- table(test_data)
  chi_res <- chisq.test(t)$stdres
  ind <- which(chi_res == max(chi_res), arr.ind = T)
  row_n <- row.names(ind)
  col_n <- colnames(chi_res)[ind[2]]
  c(row_n, col_n)
}
```
v2
```{r}
max_resid <- function(test_data){    
  d <- table(test_data) 
  chi <- chisq.test(d)
  ind <- which(chi$stdres == max(chi$stdres), arr.ind = T)
  return(c(row.names(d)[ind[1]], 
           colnames(d)[ind[2]]
           )
         )
}

max_resid(test_data)
```
v3
```{r}
max_resid <- function(x){
    std_res = data.frame(chisq.test(table(x))$stdres)
    return(as.vector(t(std_res[,1:2])[,which.max(std_res[,3])]))
}
```
v4
```{r}
max_resid <- function(x){
  s <- chisq.test(table(x))$stdres
  s <- as.matrix(data.frame(s))
  l <- c(s[which.max(s[,3]),1], s[which.max(s[,3]),2])
}
```




# Exircise 9 of 9
Ну и напоследок построим гистограмму частот при помощи ggplot2!
Чтобы получить доступ к данным:
```{r}
install.packages("ggplot2") # если у вас не установлен пакет
library("ggplot2")
```
теперь данные diamonds доступны для работы
```{r}
str(diamonds)
```
Основной способ визуализировать распределение частот номинативной переменной - гистограмма частот (барплот). Используя библиотеку ggplot2 и встроенные данные diamonds, постройте график распределения частот переменной color, на котором за цвет заполнения столбиков отвечает переменная cut. Сохраните код графика в переменную obj. В итоге должен получиться вот такой график.
Для успешной проверки вашего решения не выводите переменную obj в консоль. Просто сохраните в нее график.

```{r}
data("diamonds")

obj <- ggplot(diamonds, aes(x = color, fill = cut)) + 
            geom_bar(position = "dodge")
```
v2
```{r}
obj <- ggplot(diamonds) +
    geom_bar(aes(x=diamonds$color, fill=diamonds$cut), position='dodge')
```

v3
```{r}
obj <- ggplot(diamonds, aes(color, fill = cut)) +
  geom_bar(position = "dodge") +
  scale_fill_manual(values = c("Red", "Orange", "Lightyellow", "Lightgreen", "Darkgreen"))
```


