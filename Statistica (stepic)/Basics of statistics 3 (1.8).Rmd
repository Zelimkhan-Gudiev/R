---
title: "Basics of statistics 3 (1.8)"
author: "Zelimkhan"
date: '2023-05-08'
output: html_document
---
# Install and attach necessary packages
```{r}
install.packages("lmtest")
library(lmtest)
```

# step 1

В большинстве случаев от вас потребуется написать функцию для выполнения различных статистических операций. Давайте разберем пример задания:
Напишите функцию NA_position, которая получает на вход два числовых вектора одинаковой длины. Функция должна возвращать TRUE, если позиции NA в обоих векторах совпадают или пропущенных значений вообще нет, и значение FALSE, если позиции NA в векторах не совпадают.  
После условия задачи будут приведены примеры работы функции:
```{r}
v1  <- c(1, 2, 3)
v2  <- c(3, 4, 6)
NA_position(v1, v2)
# [1] TRUE

v1  <- c(1, 2, NA)
v2  <- c(3, 4, NA)
NA_position(v1, v2)
# [1] TRUE

v1  <- c(NA, 2, NA)
v2  <- c(3, 4, NA)
NA_position(v1, v2)
# [1] FALSE
```

Перед тем как сдавать решение я бы настоятельно рекомендовал вам убедиться в том, что ваша функция работает как минимум на тестовых данных, это позволит сразу выявить возможные ошибки (я всегда прикладываю тестовые данные с ответом). 
Для того чтобы сдать задачу введите ваш код в специальное окно, где уже написано название функции (оно появится после нажатия на клавишу "Нажмите, чтобы начать решение"). 
Примером правильного решения мог бы являться следующий код:
```{r}
NA_position  <- function(x, y){
    all(is.na(x) == is.na(y))
}

NA_position(v1, v2)
```
Вы можете называть аргументы функции, как считаете нужным, но не изменяйте название самой функции, а то мы не сможем проверить ваше решение на различных примерах. Вы можете скопировать этот код в поле для решения, нажать отправить и убедиться, что ответ засчитан.
В задачах на R не нужно округлять результаты работы вашей функции, возвращайте все значения как они есть.
Теперь предположим, что вы ошиблись, например,  решили, что вам повезет и написали функцию, которая всегда возвращает TRUE:
```{r}
NA_position  <- function(x, y){
    return(TRUE)
}
```
Тогда вы получите сообщение об ошибке. Мы постарались снабдить все задачи обратной связью, чтобы вы всегда понимали, в каком направлении нужно двигаться, чтобы справиться с задачей. Мы всегда будем писать, что вернула ваша функция, а что ожидалось в качестве правильного ответа. Там, где это возможно, я вывожу пример теста, на котором не прошло ваше решение. Поэтому читайте сообщения об ошибке! Также внимательно смотрите на примеры работы функции, и учитывайте, что мы хотим от вас на выходе. Если вы все правильно сделали, но вернули dataframe вместо требуемого вектора, возможно, мы не сможем проверить ваш ответ.
Если вы решили задачу правильно, то вы можете сравнить свое решение с решением команды курса или наиболее опытных студентов. Вы увидите вариант правильного решения в ставшей доступной вкладке Решения:

Если у вас возникают вопросы по решению, вы можете написать в комментариях, что именно вам непонятно. 
Но не нужно выкладывать ваш код, даже если он не проходит проверку. Команда курса видит ваши решения.
И так, начнем с тестового задания, чтобы увидеть, как все работает!

```{r}
NA_position  <- function(x, y){
    all(is.na(x) == is.na(y))
}

NA_position(v1, v2)
```

# step 2

Давайте реализуем простейший вариант теста для проверки наличия гетероскедастичности. Напишите функцию hetero_test, которая получает на вход набор данных. Первая колонка в данных - зависимая переменная, остальные колонки - независимые. Функция строит регрессионную модель, используя эти переменные, а затем проверяет, есть ли в данных  гетероскедастичность.

Для этого функция строит вспомогательную регрессию, в которой зависимая переменная - это квадраты остатков исходной модели, а независимые переменные - это предикторы из исходной модели. Функция должна возвращать значение R квадрат этой вспомогательной модели.

```{r}
hetero_test(mtcars)
# [1] 0.4660497
```

```{r}

hetero_test <- function(x){
 fit0 <- lm(test_data[, 1] ~ ., test_data[, -1])
 fit <- lm(fit0$residuals^2 ~ ., test_data[, -1])
 summary(fit)$r.squared 
}
```
v2
```{r}
library(magrittr)
hetero_test <-  function(test_data){
 
  cbind(res=lm(as.formula(paste0(names(test_data)[1],' ~ .')),data=test_data)$residuals**2,test_data[,-1]) %>% 
    lm(res~.,data=.) %>% summary() %>% `[[`('r.squared')
    
}
```
v3
```{r}
hetero_test <-  function(test_data){
  fit <- lm(unlist(test_data[1]) ~ ., test_data[-1])
  df <- test_data[-1]
  df$r <- residuals(fit)^2
  fit_1 <- lm(r ~ ., df)
  return((summary(fit_1))$r.squared)
}
```
v4
```{r}
library(dplyr)
hetero_test <-  function(test_data){
  fit1 <- lm(test_data[, 1] ~ ., select(test_data, -1))
  fit2 <- lm(resid(fit1)**2 ~ ., select(test_data, -1))
  return(summary(fit2)$r.squared)
}
```
v5
```{r}
hetero_test <-  function(dt){
  return(summary(lm(lm(dt[,1]~., dt[-1])$residuals^2~., dt[-1]))$r.squared)
}
```
v6
```{r}
df <- mtcars
hetero_test <-  function(df){ 
  fit <- lm(reformulate(names(df)[-1], names(df)[1]), df)
  res <- fit$residuals^2
  fit_2 <- lm(reformulate(names(df)[-1],"res"), df)
  summary(fit_2)$r.squared
}
```
v7
```{r}
hetero_test <- function(df) {
  e <- lm(df[, 1] ~ ., df[-1])$residuals
  summary(lm(e^2 ~ ., df[-1]))$r.squared
}
```

# step 3
Самостоятельно реализуйте расчет показателя vif. Напишите функцию VIF, которая получает на вход набор данных. Первая колонка в данных - зависимая переменная, остальные колонки - независимые. Функция строит регрессионную модель, используя эти переменные, а затем для каждой  независимой переменной рассчитывает показатель vif.
VIF для предиктора X рассчитывается по формуле:

$$VIF_x = \frac1{1 - R^2_x}$$
$$где\space R^2_x - это$$
R квадрат вспомогательной модели, в которой предиктор X зависимая переменная, а все остальные предикторы - независимые переменные. В формуле vif используется обычный R квадрат, а не исправленный.
Функция возвращает именованный вектор, в котором для каждого предиктора рассчитан vif. 
```{r}
VIF(mtcars)
```
      cyl      disp        hp      drat        wt      qsec        vs        am      gear 
15.373833 21.620241  9.832037  3.374620 15.164887  7.527958  4.965873  4.648487  5.357452 
     carb 
 7.908747 

```{r}
# обратите внимание на ситуацию только с двумя предикторами
set.seed(42)
test_data <- data.frame(y = rnorm(30, 5), x1 = rnorm(30, 5))
test_data$x2 <- test_data$x1^2
VIF(test_data)
#       x1       x2 
# 40.62718 40.62718 
```

# step 4
Усложним предыдущую задачу, а также используем нашу функцию VIF. Напишите функцию smart_model, которая на вход получает набор данных. Первая колонка в данных - зависимая переменная, остальные колонки - независимые. Функция строит регрессию с этими переменными и проверяет есть ли в модели переменные с показателем vif больше 10. Если хотя бы у одной переменной vif > 10, то из регрессионной модели удаляется переменная с максимальным показателем vif, если после этого в новой модели все еще остались переменные с vif больше 10, то мы опять исключаем из модели переменную с максимальным vif. Таким образом, мы исключаем по одной переменной за раз, пока в модели не останутся независимые переменные с vif не больше 10.
Особая ситуация - это когда в модели два предиктора, и для обоих vif одинаковый и больше 10, в этом случае можно исключить любой из предикторов.
Функция должна возвращать коэффициенты регрессии финальной модели.
```{r}
smart_model(mtcars)
```
(Intercept)          hp        drat          wt        qsec          vs          am 
13.80810376 -0.01225158  0.88893522 -2.60967758  0.63983256  0.08786399  2.42417670 
       gear        carb 
 0.69389707 -0.61286048
```{r}
# обратите внимание на ситуацию только с двумя предикторами
# в случае, если для обоих предикторов vif будет больше 10
# можно исключить любой из предикторов
set.seed(42)
test_data <- data.frame(y = rnorm(30, 5), x1 = rnorm(30, 5))
test_data$x2 <- test_data$x1^2
smart_model(test_data)
# (Intercept)          x2 
# 5.75507454 -0.02761232
```

# Step 5

Давайте реализуем поиск наиболее подходящей степени для трансформации независимой переменной в обычной регрессии, с одним предиктором.
Ваша функция transform_x получает на вход набор данных из двух колонок, первая колонка y и вторая x. Функция должна найти такой показатель степени для трансформации x, при котором между x и y будет максимальное абсолютное значение корреляции. Правило трансформации, как мы разбирали на лекциях:
$$
\vec{x_\lambda}=
\begin{cases}
x^\lambda \hspace{1.3cm} if\space\lambda > 0             \\
logx  \hspace{1cm} if\space\lambda  = 0                  \\
x \hspace{1.5cm} if\space\lambda  < 0 
\end{cases}
$$


Функция должна вернуть трансформированную переменную x. Обратите внимание, что вместо возведения в нулевую степень мы будем логарифмировать переменную. В этом примере давайте ограничимся показателями степени от -2 до 2 с шагом 0.1.  
Гарантируется, что значения переменных в данных неотрицательные.

```{r}
set.seed(42)
test_data <- data.frame(y = rnorm(10, 10, 1), x = rnorm(10, 10, 1))  
transform_x(test_data)
# [1] 127.80008 150.96166  74.15172  94.50195  97.35135 113.12344  94.39574  53.92765  57.14654 128.14497
```




