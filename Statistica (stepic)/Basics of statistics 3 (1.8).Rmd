---
title: "Basics of statistics 3 (1.8)"
author: "Zelimkhan"
date: '2023-05-08'
output: html_document
---
# Install and attach necessary packages
```{r}
install.packages("lmtest")
library(lmtest)
```

# step 1

В большинстве случаев от вас потребуется написать функцию для выполнения различных статистических операций. Давайте разберем пример задания:
Напишите функцию NA_position, которая получает на вход два числовых вектора одинаковой длины. Функция должна возвращать TRUE, если позиции NA в обоих векторах совпадают или пропущенных значений вообще нет, и значение FALSE, если позиции NA в векторах не совпадают.  
После условия задачи будут приведены примеры работы функции:
```{r}
v1  <- c(1, 2, 3)
v2  <- c(3, 4, 6)
NA_position(v1, v2)
# [1] TRUE

v1  <- c(1, 2, NA)
v2  <- c(3, 4, NA)
NA_position(v1, v2)
# [1] TRUE

v1  <- c(NA, 2, NA)
v2  <- c(3, 4, NA)
NA_position(v1, v2)
# [1] FALSE
```

Перед тем как сдавать решение я бы настоятельно рекомендовал вам убедиться в том, что ваша функция работает как минимум на тестовых данных, это позволит сразу выявить возможные ошибки (я всегда прикладываю тестовые данные с ответом). 
Для того чтобы сдать задачу введите ваш код в специальное окно, где уже написано название функции (оно появится после нажатия на клавишу "Нажмите, чтобы начать решение"). 
Примером правильного решения мог бы являться следующий код:
```{r}
NA_position  <- function(x, y){
    all(is.na(x) == is.na(y))
}

NA_position(v1, v2)
```
Вы можете называть аргументы функции, как считаете нужным, но не изменяйте название самой функции, а то мы не сможем проверить ваше решение на различных примерах. Вы можете скопировать этот код в поле для решения, нажать отправить и убедиться, что ответ засчитан.
В задачах на R не нужно округлять результаты работы вашей функции, возвращайте все значения как они есть.
Теперь предположим, что вы ошиблись, например,  решили, что вам повезет и написали функцию, которая всегда возвращает TRUE:
```{r}
NA_position  <- function(x, y){
    return(TRUE)
}
```
Тогда вы получите сообщение об ошибке. Мы постарались снабдить все задачи обратной связью, чтобы вы всегда понимали, в каком направлении нужно двигаться, чтобы справиться с задачей. Мы всегда будем писать, что вернула ваша функция, а что ожидалось в качестве правильного ответа. Там, где это возможно, я вывожу пример теста, на котором не прошло ваше решение. Поэтому читайте сообщения об ошибке! Также внимательно смотрите на примеры работы функции, и учитывайте, что мы хотим от вас на выходе. Если вы все правильно сделали, но вернули dataframe вместо требуемого вектора, возможно, мы не сможем проверить ваш ответ.
Если вы решили задачу правильно, то вы можете сравнить свое решение с решением команды курса или наиболее опытных студентов. Вы увидите вариант правильного решения в ставшей доступной вкладке Решения:

Если у вас возникают вопросы по решению, вы можете написать в комментариях, что именно вам непонятно. 
Но не нужно выкладывать ваш код, даже если он не проходит проверку. Команда курса видит ваши решения.
И так, начнем с тестового задания, чтобы увидеть, как все работает!

```{r}
NA_position  <- function(x, y){
    all(is.na(x) == is.na(y))
}

NA_position(v1, v2)
```

# step 2

Давайте реализуем простейший вариант теста для проверки наличия гетероскедастичности. Напишите функцию hetero_test, которая получает на вход набор данных. Первая колонка в данных - зависимая переменная, остальные колонки - независимые. Функция строит регрессионную модель, используя эти переменные, а затем проверяет, есть ли в данных  гетероскедастичность.

Для этого функция строит вспомогательную регрессию, в которой зависимая переменная - это квадраты остатков исходной модели, а независимые переменные - это предикторы из исходной модели. Функция должна возвращать значение R квадрат этой вспомогательной модели.

```{r}
hetero_test(mtcars)
# [1] 0.4660497
```

```{r}

hetero_test <- function(x){
 fit0 <- lm(test_data[, 1] ~ ., test_data[, -1])
 fit <- lm(fit0$residuals^2 ~ ., test_data[, -1])
 summary(fit)$r.squared 
}
```
v2
```{r}
library(magrittr)
hetero_test <-  function(test_data){
 
  cbind(res=lm(as.formula(paste0(names(test_data)[1],' ~ .')),data=test_data)$residuals**2,test_data[,-1]) %>% 
    lm(res~.,data=.) %>% summary() %>% `[[`('r.squared')
    
}
```
v3
```{r}
hetero_test <-  function(test_data){
  fit <- lm(unlist(test_data[1]) ~ ., test_data[-1])
  df <- test_data[-1]
  df$r <- residuals(fit)^2
  fit_1 <- lm(r ~ ., df)
  return((summary(fit_1))$r.squared)
}
```
v4
```{r}
library(dplyr)
hetero_test <-  function(test_data){
  fit1 <- lm(test_data[, 1] ~ ., select(test_data, -1))
  fit2 <- lm(resid(fit1)**2 ~ ., select(test_data, -1))
  return(summary(fit2)$r.squared)
}
```
v5
```{r}
hetero_test <-  function(dt){
  return(summary(lm(lm(dt[,1]~., dt[-1])$residuals^2~., dt[-1]))$r.squared)
}
```
v6
```{r}
df <- mtcars
hetero_test <-  function(df){ 
  fit <- lm(reformulate(names(df)[-1], names(df)[1]), df)
  res <- fit$residuals^2
  fit_2 <- lm(reformulate(names(df)[-1],"res"), df)
  summary(fit_2)$r.squared
}
```
v7
```{r}
hetero_test <- function(df) {
  e <- lm(df[, 1] ~ ., df[-1])$residuals
  summary(lm(e^2 ~ ., df[-1]))$r.squared
}
```

# step 3
Самостоятельно реализуйте расчет показателя vif. Напишите функцию VIF, которая получает на вход набор данных. Первая колонка в данных - зависимая переменная, остальные колонки - независимые. Функция строит регрессионную модель, используя эти переменные, а затем для каждой  независимой переменной рассчитывает показатель vif.
VIF для предиктора X рассчитывается по формуле:

$$VIF_x = \frac1{1 - R^2_x}$$
$$где\space R^2_x - это$$
R квадрат вспомогательной модели, в которой предиктор X зависимая переменная, а все остальные предикторы - независимые переменные. В формуле vif используется обычный R квадрат, а не исправленный.
Функция возвращает именованный вектор, в котором для каждого предиктора рассчитан vif. 
```{r}
VIF(mtcars)
```
      cyl      disp        hp      drat        wt      qsec        vs        am      gear 
15.373833 21.620241  9.832037  3.374620 15.164887  7.527958  4.965873  4.648487  5.357452 
     carb 
 7.908747 

```{r}
# обратите внимание на ситуацию только с двумя предикторами
set.seed(42)
test_data <- data.frame(y = rnorm(30, 5), x1 = rnorm(30, 5))
test_data$x2 <- test_data$x1^2
VIF(test_data)
#       x1       x2 
# 40.62718 40.62718 
```
v1
```{r}
# Функция для вычисления значения VIF (Variance Inflation Factor) для каждой переменной в наборе данных
# test_data - набор данных, для которого нужно вычислить VIF

VIF <- function(test_data) {
  # Создаем копию набора данных, исключая первый столбец (предполагаемый отклик)
  test_df <- data.frame(test_data[, -1])
  
  # Создаем пустой вектор для хранения значений VIF
  VIF_df <- numeric(0)
  
  # Проходим по всем столбцам в наборе данных
  for (i in 1:ncol(test_df)) {
    # Строим линейную модель для текущего столбца, предсказывая его значения на основе остальных столбцов
    model <- lm(test_df[, i] ~ as.matrix(test_df[, -i]), data = test_df)
    
    # Вычисляем значение VIF для текущего столбца на основе коэффициента детерминации модели
    VIF_test <- 1 / (1 - summary(model)$r.squared)
    
    # Добавляем значение VIF в конец вектора VIF_df
    VIF_df <- c(VIF_df, VIF_test)
    
    # Задаем имя текущего столбца как имя соответствующего элемента вектора VIF_df
    names(VIF_df)[i] <- names(test_df)[i]
  }
  
  # Возвращаем вектор, содержащий значения VIF для каждого столбца в наборе данных
  return(VIF_df)
}

# Пример использования функции VIF с набором данных mtcars
VIF(mtcars)
```
v2
```{r}
library(dplyr)
name <- select(data, cyl) %>% names()
VIF <- function(data)
{
  sapply(names(data[-1]), function(name) {
    m = lm(as.formula(paste(name, "~ .")), data[-1])
    r2 = summary(m)$r.squared
    1 / (1 - r2)})
}
```
v3
```{r}
VIF <- function(d) {
    x <- d[,-1]
    sapply(names(x), function(y) 1/(1-summary(lm(as.formula(paste(y,"~.")), x))$r.sq) )
}
```
v4
```{r}
VIF <-  function(dat){
  library(car)
  names(dat)[1] <- "my_name"
  fit <- lm(my_name ~ ., dat)
  vif(fit)
}
```










# step 4
Усложним предыдущую задачу, а также используем нашу функцию VIF. Напишите функцию smart_model, которая на вход получает набор данных. Первая колонка в данных - зависимая переменная, остальные колонки - независимые. Функция строит регрессию с этими переменными и проверяет есть ли в модели переменные с показателем vif больше 10. Если хотя бы у одной переменной vif > 10, то из регрессионной модели удаляется переменная с максимальным показателем vif, если после этого в новой модели все еще остались переменные с vif больше 10, то мы опять исключаем из модели переменную с максимальным vif. Таким образом, мы исключаем по одной переменной за раз, пока в модели не останутся независимые переменные с vif не больше 10.
Особая ситуация - это когда в модели два предиктора, и для обоих vif одинаковый и больше 10, в этом случае можно исключить любой из предикторов.
Функция должна возвращать коэффициенты регрессии финальной модели.
```{r}
smart_model(mtcars)
```
(Intercept)          hp        drat          wt        qsec          vs          am 
13.80810376 -0.01225158  0.88893522 -2.60967758  0.63983256  0.08786399  2.42417670 
       gear        carb 
 0.69389707 -0.61286048
```{r}
# обратите внимание на ситуацию только с двумя предикторами
# в случае, если для обоих предикторов vif будет больше 10
# можно исключить любой из предикторов
set.seed(42)
test_data <- data.frame(y = rnorm(30, 5), x1 = rnorm(30, 5))
test_data$x2 <- test_data$x1^2
smart_model(test_data)
# (Intercept)          x2 
# 5.75507454 -0.02761232
```
v1
```{r}
VIF <- function(test_data) {
  # !!! оставляем первый столбец, т.к. его отделение происходит в функции smart_model
  test_df <- data.frame(test_data)
  
  # Создаем пустой вектор для хранения значений VIF
  VIF_df <- numeric(0)
  
  # Проходим по всем столбцам в наборе данных
  for (i in 1:ncol(test_df)) {
    # Строим линейную модель для текущего столбца, предсказывая его значения на основе остальных столбцов
    model <- lm(test_df[, i] ~ as.matrix(test_df[, -i]), data = test_df)
    
    # Вычисляем значение VIF для текущего столбца на основе коэффициента детерминации модели
    VIF_test <- 1 / (1 - summary(model)$r.squared)
    
    # Добавляем значение VIF в конец вектора VIF_df
    VIF_df <- c(VIF_df, VIF_test)
    
    # Задаем имя текущего столбца как имя соответствующего элемента вектора VIF_df
    names(VIF_df)[i] <- names(test_df)[i]
  }
  
  # Возвращаем вектор, содержащий значения VIF для каждого столбца в наборе данных
  return(VIF_df)
}

smart_model <- function(df){
  # отделяем зависимую переменную от независимых
  # зависимая
  y <- df[, 1]
  # независимые
  X <- df[, -1]
  
  # рассчитываем для независимых коэффициенты vif с помощью модифицированной функции VIF
  vifs <- VIF(X)
  
  # получаем индекс колонки с максимальным VIF (первое значение для отсортированных по убыванию)
  # примечание: order возвращает индексы, а не сами значения
  max_index <- order(vifs, decreasing = TRUE)[1]
  
  # цикл: до тех пор пока в массиве vifs максимальное значение будет больше 10
  while(vifs[max_index] > 10){
    # удаляем колонку с максимальным VIF из независимых переменных
    X <- X[, -max_index, drop=FALSE]
    
    # если количество признаков в массиве после удаления больше 1
    if(dim(X)[2] > 1){
      # пересчитываем VIF для нового набора независимых переменных
      vifs <- VIF(X)
      # получаем новый индекс с максимальным значение VIF 
      max_index <- order(vifs, decreasing = TRUE)[1]
    }
    else{
      break
    }

  }
  # строим модель на оставшихся признаках
  model <- lm(y ~ as.matrix(X))
  return(model$coefficients)
}
```
v2
```{r}
VIF <- function(d) {
  x <- d[,-1]
  if (ncol(d) > 2) {
    sapply(names(x), function(y) 1/(1-summary(lm(as.formula(paste(y,"~.")), x))$r.sq) )
  } else 0
}
           
smart_model <- function(d) {
  vif <- VIF(d)
  if (max(vif) > 10) { 
    smart_model(d[, -(which.max(vif) + 1)])
  } else lm(d)$coeff
}
```

v3
```{r}
VIF <- function(data)
{
  sapply(names(data[-1]), function(name) {
    m = lm(as.formula(paste(name, "~ .")), data[-1])
    r2 = summary(m)$r.squared
    1 / (1 - r2)})
} 

smart_model <-  function(test_data){
  while(max(VIF(test_data)) > 10){
    ind <- which.max(VIF(test_data))
    test_data <- test_data[-(ind + 1)]
  }
  
  lm(test_data)$coefficients
}
```
v4
```{r}
smart_model <-  function(test_data){
    # Создаем df без оригинальной ЗП
    d <- test_data[-1]
    # Задаем начальный максимальный VIF больше 10 
    max_vif=11
    # Гоняем код пока не останется VIF больше 10
    while(max_vif>10) {
        # Находим все VIF в d
        y <- sapply(colnames(d), function(x) {
            1/(1-summary(lm(as.formula(paste(x,"~.")),d))$r.squared)
        })
        # Находим текущий максимальный VIF
        max_vif <- max(y)
        # Убираем переменную из d с наибольшим VIF, если тот больше 10
        if (max_vif>10) {
            d <- d[-which.max(y)]
        }
    }
    # Получаем коэффициенты
    lm(test_data[,1]~.,d)$coef
}
```



# Step 5

Давайте реализуем поиск наиболее подходящей степени для трансформации независимой переменной в обычной регрессии, с одним предиктором.
Ваша функция transform_x получает на вход набор данных из двух колонок, первая колонка y и вторая x. Функция должна найти такой показатель степени для трансформации x, при котором между x и y будет максимальное абсолютное значение корреляции. Правило трансформации, как мы разбирали на лекциях:
$$
\vec{x_\lambda}=
\begin{cases}
x^\lambda \hspace{1.3cm} if\space\lambda > 0             \\
logx  \hspace{1cm} if\space\lambda  = 0                  \\
x \hspace{1.5cm} if\space\lambda  < 0 
\end{cases}
$$


Функция должна вернуть трансформированную переменную x. Обратите внимание, что вместо возведения в нулевую степень мы будем логарифмировать переменную. В этом примере давайте ограничимся показателями степени от -2 до 2 с шагом 0.1.  
Гарантируется, что значения переменных в данных неотрицательные.

```{r}
set.seed(42)
test_data <- data.frame(y = rnorm(10, 10, 1), x = rnorm(10, 10, 1))  
transform_x(test_data)
# [1] 127.80008 150.96166  74.15172  94.50195  97.35135 113.12344  94.39574  53.92765  57.14654 128.14497
```

v1
```{r}
# функция для применения степени лямбда к х (правило трансформации)
apply_lambda <- function(x, lambda){
  if(lambda < 0) return(-x**lambda)
  else if(lambda == 0) return(log(x))
  else return(x**lambda)
}

# основная функция
transform_x <-  function(test_data){
  # разделяем переменные
  y <- test_data[, 1]
  x <- test_data[, 2]
  
  # задаем диапазон для лямбда
  lambdas <- seq(-2,2,0.1)
  
  # ставим начальное максимальное значение корреляции на 0
  max_cor <- 0
  # переменная для сохранения ответа
  final_x <- NULL
  
  # проходим по всем лямбда из диапазона
  for(lambda in lambdas){
    # трансформируем х под текущую лямбда
    new_x <- apply_lambda(x, lambda)
    # считаем трансформацию между трансформированным х и у
    new_cor <- cor(y, new_x)
    
    # если текущая корреляция больше по модулю чем значение в max_cor
    if(abs(new_cor) > abs(max_cor)){
      # записываем в max_cor текущее значение
      max_cor <- new_cor
      # записываем в ответ текущий трансформированный х
      final_x <- new_x
    }
  }
  return(final_x)
}
```

v2
```{r}
transform_x <- function(test_data) {
    y <- test_data[[1]]
    x <- test_data[[2]]
    # Диапазон значений лямбда
    l <- seq(-2, 2, 0.1)
    # Трансформация
    d <- outer(x, l, "^")
    # Изменяем знак
    d[, l < 0] <- -d[, l < 0]
    # Для случая, где лямбда равна нулю
    d[, l == 0] <- log(x)
    # Расчёт корреляций
    r <- cor(d, y)[, 1]
    # Выбор оптимального значения
    d[, which.max(abs(r))]
}
```


