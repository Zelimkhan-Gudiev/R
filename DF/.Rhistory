my_data[, 1] # можно обратиться к первому стобцу. В таком случае мы увидим все значения первой переменной (столбца).
View(my_data[, 1])
# Вектор "my_data[, 1]" полностью повторяет значения my_data$score
my_data[, 1] == my_data$score # Вектор "my_data[, 1]" полностью повторяет значения my_data$score
my_data[, 2:5] # Также как и строки можно вызывать столбцы
View(my_data[, 2:5])
View(head(my_data[, 2:5]))
View(my_data)
View(head(my_data[, 2:5]))
yt$ktd[1:10]
yt[1, 3]
View(yt)
yt[c(1:5), c(2,3)]
View(yt[c(1:5), c(2,3)])
my_data$gender # обратимя к переменной my_data$gender
my_data$gender == 'female' # проверим каким строкам (наблюдений) соответствуют значение 'female'.
# попрубуем использовать данные знания для обращения к конкретным значениям дата фрейма
my_data[,1] # если мы выполним данную комманду мы получим все значения первого столбца, т.к. мы пропустили индекс строки
# но мы можем использовать логический вектор для обращения к части данных
my_data[my_data$gender =='female', 1] # если в качестве индекса строки указать логиический вектор, то мы получим только те
# значения первого столбца, значения строк которых отвечает требованиям my_data$gender =='female'
my_data[my_data$gender == 'female', 1:3] # можно обращаться к любому количеству столбцов, например к первым трем стобцам
View(my_data[my_data$gender == 'female', c(1:3)])
head(my_data[my_data$gender == 'female', 1:3])
# В R есть функция, которая позволяет нам обращается к .. данным без индексации
subset(my_data, gender == 'female') # в качестве условия указана факторная перменная gender
View(subset(my_data, gender == 'female'))
head(subset(my_data, gender == 'female'))
subset(my_data, score > 3.5) # в качестве условия указана количественная перменная score
View(subset(my_data, score > 3.5))
head(subset(my_data, score > 3.5))
subset(my_data, score < 3.5)
View(subset(my_data, score < 3.5))
head(subset(my_data, score < 3.5))
subset(my_data, score == 3.5)
View(subset(my_data, score == 3.5))
head(subset(my_data, score = 3.5))
yt[yt$duration > mean(yt$duration, na.rm = T), 3]
yt[yt$duration > mean(yt$duration, na.rm = T), 3]
yt[yt$deputy == "Гудиев Зелимхан Куйраевич", 3]
yt[yt$deputy == "Гудиев Зелимхан Куйраевич" & yt$duration > mean(yt$duration, na.rm = T), 3]
View(yt[yt$deputy == "Гудиев Зелимхан Куйраевич" & yt$duration > mean(yt$duration, na.rm = T), c(1:3)])
subset(yt, deputy == 'Гудиев Зелимхан Куйраевич')
View(subset(yt, deputy == "Гудиев Зелимхан Куйраевич"))
#### rbind, cbind (rowbind - соединение по строкам, columnbind - соединение по столбцам) _____________________________________________________ ####
# rbind (rowbind) - соединяет два дата фрейма по строкам
# для демонтрации того, что делает функция rbind создадим два дата фрейма my_data2, my_data3
my_data2 <- subset(my_data, gender == 'female') # дата фрейм my_data2 будет содержать только те наблюдения где преподователь женщина
#### rbind, cbind (rowbind - соединение по строкам, columnbind - соединение по столбцам) _____________________________________________________ ####
# rbind (rowbind) - соединяет два дата фрейма по строкам
# для демонтрации того, что делает функция rbind создадим два дата фрейма my_data2, my_data3
my_data2 <- subset(my_data, gender == 'female') # дата фрейм my_data2 будет содержать только те наблюдения где преподователь женщина
my_data3 <- subset(my_data, gender == 'male') # дата фрейм my_data3 будет содержать только те наблюдения где преподователь мужчина
my_data4 <- rbind(my_data2, my_data3) # rbind соединяет два дата фрейма с одиновым количеством столбцов (наименования столбцов должны совпадать)
# cbind (columnbind) - соединяет два дата фрейма по столбцам
# для демонтрации того, что делает функция rbind создадим два дата фрейма my_data5, my_data6
my_data5 <- my_data[, 1:10] # создадим дата фрейм my_data5, в котором будут все строки, но столбцы только с 1 по 10
my_data5
# cbind (columnbind) - соединяет два дата фрейма по столбцам
# для демонтрации того, что делает функция rbind создадим два дата фрейма my_data5, my_data6
my_data5 <- my_data[, 1:10] # создадим дата фрейм my_data5, в котором будут все строки, но столбцы только с 1 по 10
my_data6 <- my_data[, 11:24] # создадим дата фрейм my_data6, в котором будут все строки, но столбцы только с 1 по 24
my_data7 <- cbind(my_data5, my_data6) # cbind соединяет два дата фрейма по столбцам
yt1 <- subset(yt, deputy == "Гудиев Зелимхан Куйраевич")
yt2 <- subset(yt, deputy == "Чурсина Мария Вячеславовна")
yt3 <- subset(yt, deputy == "Магамгазиев Расул Висхаджиевич")
yt4 <- subset(yt, deputy == "Майоров Артем Сергеевич")
yt5 <- subset(yt, deputy == "")
yt6 <- rbind(yt1, yt2, yt3, yt4, yt5)
yt11 <- yt[, 1:28]
yt22 <- yt[, 29:56]
yt66 <- cbind(yt11, yt22)
library(help = 'datasets') # Чтобы просмотреть весь список доступных датасетов, выполните команду library(help = "datasets")
mtcars # Команда mtcars выводит данные в консоли
data(mtcars) # Команда data(mtcars) добавит датасет в рабочую среду
remove(list = ls())
data(mtcars) # Команда data(mtcars) добавит датасет в рабочую среду
help(mtcars) # Команда help(mtcars) выведет информацию о датасете (?mtcars)
mydata <- mtcars # Команда my_data <- mtcars запишет датасет в новую переменную
#### Step 7 of 11. Задача _____________________________________________________________________________________________________________________ ####
# В этой задче поработаем со встроенными данными mtcars. В датафрэйме mtcars создайте новую колонку (переменную)
# под названием even_gear, в которой будут единицы, если значение переменной (gear) четное, и нули если количество нечетное.
# Подсказка: вам может помочь оператор деления с остатком:5 %% 2 == 1 TRUE
5 %% 2
4 %% 2
# Решения
# Вариант 1
mtcars$even_gear <- ifelse (mtcars$gear %% 2 == 1, 0, 1) # если остаток деления значения переменной mtcars$gear на 2 равно 1,
View(mtcars)
View(mtcars[, c('cyl', 'mpg')])
# Вариант 1
mpg_4.1 <- mtcars$mpg[mtcars$cyl == 4]
# yt
yt$duration[yt$deputy == "Гудиев Зелимхан Куйраевич"]
sort(yt$duration[yt$deputy == "Гудиев Зелимхан Куйраевич"])
# Вариант 2
s <-subset(mtcars, cyl == 4)
mpg_4.2 <- s$mpg
# Вариант 4
mpg_4 <- subset(mtcars, cyl == 4)$mpg
# yt
subset(yt, deputy == "Гудиев Зелимхан Куйраевич")$duration
sort(subset(yt, deputy == "Гудиев Зелимхан Куйраевич")$duration)
# Вариант 5
mpg_4 <- subset(mtcars$mpg, mtcars$cyl == '4')
# Вариант 6
mpg_4 <-mtcars[mtcars$cyl == '4', 1]
# yt
which(colnames(yt) == "duration")
# Вариант 7
s <-subset(mtcars, cyl == 4)
remove(list = ls())
mydata <-  read.csv("/Users/zelimkhan/Desktop/evals.csv") # не работает
mydata <- read.csv('evals.csv')
yt <- read.csv2('yt.csv') # Отступление
# принимает на вход условие (одно логическое значение), что выдает на выходе TRUE or FALSE
# оператор if: 1) принимает на вход условие; 2) затем проверяет выполняется ли данное условие;
# 3) если выполняестя, то выполняет некоторую комманду; 4) если условие не выполняется то выполняет другую комманду
a <- -10
# два варианта
if (a > 0) { # 1) принимает на вход условие if (a > 0); 2) затем проверяет выполняется ли данное условие;
print('positive') # 3) если выполняестя, то выполняет некоторую комманду print('positive');
} else('not positive') # 4) если условие не выполняется то выполняет другую комманду else('not positive');
# два варианта + действие (a + 1)
if (a > 0) {
print('positive')
} else { # Если после else не использовать фигурные скобки { } то мы сможем выполнить только одно действие print('not positive'). Если хотим выполнить более одного действия, нужно использовать фигурные скобки { }
print('not positive')
print(a + 1) # + действие (a + 1)
}
# два варианта + действие (a + 1)
if (a > 0) {
print('positive')
} else { # Если после else не использовать фигурные скобки { } то мы сможем выполнить только одно действие print('not positive'). Если хотим выполнить более одного действия, нужно использовать фигурные скобки { }
print('not positive')
print(a + 1) # + действие (a + 1)
}
# три варианта
if (a > 0) {
print('positive')
} else if (a < 0) {
print('negative')
} else print('zero')
#### yt (if) __________________________________________________________________________________________________________________________________ ####
# Warning messages:
# В отличии от ifelse операторр if не позволяет работать с векторами произвольной длины.
# при выполнении нижеуказанной функции будет выдано только одно значение ("positive") для первого значения вектора a <- c(1, -1), т.е. для 1
if (yt$duration < mean(yt$duration, na.rm = T)) {
print('dur_less_than_mean')
} else if (yt$duration > mean(yt$duration, na.rm = T)) {
print('dur_more_than_mean')
} else print('dur_equal_mean')
# ifelse позволяет записать вышеуказанную конструкцию в одну строку
a <- 10
ifelse(a > 0, 'positive', 'not positive')
a <- c(1, -1) # ifelse позволяет работать с векторами произвольной длины. В данном случае длина вектора а равняется двум a <- c(1, -1)
ifelse(a > 0, 'positive', 'not positive') # в данном случае ifelse выдает два значения 'positive' и 'not positive'
# В отличии от ifelse операторр if не позволяет работать с векторами произвольной длины.
# при выполнении нижеуказанной функции будет выдано только одно значение ("positive") для первого значения вектора a <- c(1, -1), т.е. для 1
a <- c(1, -1)
if (a > 0) {
print('positive')
} else if (a < 0) {
print('negative')
} else print('zero')
#### yt (felse) _______________________________________________________________________________________________________________________________ ####
# error
ifelse(yt$duration <= mean(yt$duration, na.rm = T), "dur less than mean/dur equal mean ","dur more than mean")
less_or_equal_or_more_than_mean <- ifelse(yt$duration <= mean(yt$duration, na.rm = T), "dur less than mean/dur equal mean","dur more than mean")
length(less_or_equal_or_more_than_mean[less_or_equal_or_more_than_mean == 'dur more than mean'])
length(less_or_equal_or_more_than_mean[less_or_equal_or_more_than_mean == "dur less than mean/dur equal mean"])
mean(yt$duration, na.rm = T)
length(yt[yt$duration == 130.2266])
# v2 # error
p1 <- ifelse(yt$duration < mean(yt$duration, na.rm = T), "dur less than mean","other")
length(p1[p1 == "dur less than mean"])
length(p1[p1 == "other"])
p2 <- ifelse(yt$duration > mean(yt$duration, na.rm = T), "dur more than mean", "other")
length(p2[p2 == "dur less than mean"])
length(p2[p2 == "other"])
p3 <- ifelse(yt$duration == mean(yt$duration, na.rm = T), "dur equal mean","other")
length(p2[p2 == "dur more than mean"])
length(p2[p2 == "other"])
p3 <- ifelse(yt$duration == mean(yt$duration, na.rm = T), "dur equal mean","other")
length(p3[p3 == "dur equal mean"])
length(p3[p3 == "other"])
yt$ktd[yt$duration == mean(yt$duration, na.rm = T)]
# оператор for на вход должен получать вектор значений in 1:10
# цикл for позволяет выполнять много раз рутинную операцию (с каждым элементом вектора)
for (i in 1:10) {
print(i)
}
# for делает следующее: i пробегает значения от 1 до количества строк в дата фрейме и выводит значения yt$duration из i строки
for(i in 1:nrow(yt)) {
print(yt$duration[i])
}
for(i in 1:nrow(yt)) {
print(yt$ktd[i])
}
for (i in 1:nrow(mydata)) {
print(mydata$score[i])
}
for (i in 1:nrow(mydata)) {           # for принимает на вход вектор. Вектор от 1 до количества строк в mydata
if (mydata$gender[i] == 'male') {   # if принимает на вход вектор и условие. Если i значние mydata$gender[i] равно 'male'
print(mydata$score[i])            # print(mydata$score[i] выводит i значние переменной score. Выводит значние переменной score для всех строк где значние mydata$gender[i] равно 'male' по всем строкам от 1 до nrow(mydata)
}
}
for(i in 1:nrow(yt)) {
if(yt$numb_ret_depir[i] > 5) {
print(yt$name[i])
}
}
for(i in 1:nrow(yt)) {
if(yt$numb_ret_depir[i] > 3) {
ksk <- data.frame(yt$name[i], yt$teamleader[i], yt$numb_ret_depir[i])
}
}
View(ksk)
mydata$quality <- rep(NA, nrow(mydata)) # Создадим новую переменную quality с пустыми значениями и длиной nrow(mydata).
mydata$quality
View(yt)
View(mydata)
for (i in 1:nrow(mydata)) {             # задаем вектор, который должен пробегать оператор for
if (mydata$score[i] > 4){             # задаем условия для операторра if. Проверяем в i строке mydata$score больше 4
mydata$quality[i] <- 'good'         # указываем действие, которое необходимо выполнить если условие выполнено. Если в i строке значение mydata$score больше 4, то в этой i строке в столбце mydata$quality записываем значение 'good'
} else mydata$quality[i] <- 'bad'     # указываем действие, которое необходимо выполнить если условие не выполнено. Если в i строке значение mydata$score не больше 4, то в этой i строке в столбце mydata$quality записываем значение 'bad'
}
yt$quality <- rep(NA, nrow(yt))
for (i in 1:nrow(yt)) {
if (yt$duration[i] > mean(yt$duration, na.rm = T)) {
yt$quality[i] <- "dur more than mean"
} if (yt$duration[i] < mean(yt$duration, na.rm = T)) {
yt$quality[i] <- "dur less than mean"
} else yt$quality[i] <- "dur equal mean"
}
yt$quality <- rep(NA, nrow(yt))
View(yt)
for (i in 1:nrow(yt)) {
if (yt$duration[i] > mean(yt$duration, na.rm = T)) {
yt$quality[i] <- "dur more than mean"
} if (yt$duration[i] < mean(yt$duration, na.rm = T)) {
yt$quality[i] <- "dur less than mean"
} else yt$quality[i] <- "dur equal mean"
}
if (yt$duration[i] > mean(yt$duration, na.rm = T)) {
yt$quality[i] <- "dur more than mean"
} if else (yt$duration[i] < mean(yt$duration, na.rm = T)) {
yt$quality[i] <- "dur less than mean"
} else yt$quality[i] <- "dur equal mean"
for (i in 1:nrow(yt)) {
if (yt$duration[i] > mean(yt$duration, na.rm = T)) {
yt$quality[i] <- "dur more than mean"
} else if (yt$duration[i] < mean(yt$duration, na.rm = T)) {
yt$quality[i] <- "dur less than mean"
} else yt$quality[i] <- "dur equal mean"
}
# error
length(yt$quality[yt$quality == "dur more than mean"])
length(yt$quality[yt$quality == "dur less than mean"])
length(yt$quality[yt$quality == "dur equal mean"])
# С помощью ifelse можно выполнить все вышеуказанное в одну строчку
mydata$quality2 <- ifelse(mydata$score > 4, 'good', 'bad') # mydata$score > 4 проверяет в каждой (i) строке mydata$score больше 4
# yt
yt$quality2 <-  ifelse(yt$duration > mean(yt$duration, na.rm = T), "dur more than mean", "dur less than mean/dur equal mean")
i <- 1
while (i < 51) {            # оператор while будет выполнять нижеуказанные действия до тех пор пока i < 51, т.е с 1 до 51-й строки
print(mydata$score[i])    # если i < 51, то выводим значение столбца mydata$score и так до тех пор пока (i < 51)
i <- i + 1                # если i < 51, то добавляем 1 к i (i + 1) и так до тех пор пока (i < 51)
}
# Вариант 1
mtcars$new_var <- ifelse((mtcars$carb >= 4 | mtcars$cyl > 6), '1', '0')
# yt
yt$score <- ifelse((yt$numb_ret_depir >= 4 | yt$numb_ret_oiv >= 4), 'Bad', 'Norm') # отсупление
View(yt)
yt$score2 <- ifelse((yt$numb_ret_depir >= mean(numb_ret_depir) | yt$numb_ret_oiv >= mean(numb_ret_depir), 'Bad', 'Norm')
yt$score2 <- ifelse((yt$numb_ret_depir >= mean(yt$numb_ret_depir) | yt$numb_ret_oiv >= mean(yt$numb_ret_depir), 'Bad', 'Norm')
yt$score2 <- ifelse((yt$numb_ret_depir >= mean(yt$numb_ret_depir) | yt$numb_ret_oiv >= mean(yt$numb_ret_depir), 'Bad', 'Norm'))
yt$score2 <- ifelse((yt$numb_ret_depir >= mean(yt$numb_ret_depir)) | (yt$numb_ret_oiv >= mean(yt$numb_ret_depir)), 'Bad', 'Norm')
length(yt$score[yt$score == 'Bad'])
length(yt$score[yt$score == 'Norm'])
49+58
# Вариант 2
for (i in 1:nrow(mtcars)){
if (mtcars$carb[i] >= 4  |  mtcars$cyl[i] > 6){
mtcars$new_var1[i] = 1
}
else mtcars$new_var1[i] = 0
}
# Вариант 2
for (i in 1:nrow(mtcars)){
if (mtcars$carb[i] >= 4  |  mtcars$cyl[i] > 6){
mtcars$new_var1[i] = 1
}
else mtcars$new_var1[i] = 0
}
# yt
yt$quality3 <- rep(NA, nrow(yt))
for (i in i:nrow(yt)) {
if (yt$duration[i] > mean(yt$duration, na.rm = T)) {
yt$quality3[i] <- "dur more than mean"
} if (yt$duration[i] < mean(yt$duration, na.rm = T)) {
yt$quality3[i] <- "dur less than mean"
} else yt$quality3[i] <- "dur equal mean"
}
if (yt$duration[i] > mean(yt$duration, na.rm = T)) {
yt$quality3[i] <- "dur more than mean"
} else if (yt$duration[i] < mean(yt$duration, na.rm = T)) {
yt$quality3[i] <- "dur less than mean"
} else yt$quality3[i] <- "dur equal mean"
for (i in i:nrow(yt)) {
if (yt$duration[i] > mean(yt$duration, na.rm = T)) {
yt$quality3[i] <- "dur more than mean"
} else if (yt$duration[i] < mean(yt$duration, na.rm = T)) {
yt$quality3[i] <- "dur less than mean"
} else yt$quality3[i] <- "dur equal mean"
}
for (i in 1:nrow(yt)) {
if (yt$duration[i] > mean(yt$duration, na.rm = T)) {
yt$quality3[i] <- "dur more than mean"
} else if (yt$duration[i] < mean(yt$duration, na.rm = T)) {
yt$quality3[i] <- "dur less than mean"
} else yt$quality3[i] <- "dur equal mean"
}
for (i in i:nrow(yt)) {
if (yt$duration[i] > mean(yt$duration, na.rm = T)) {
yt$quality3[i] <- "dur more than mean"
} else if (yt$duration[i] < mean(yt$duration, na.rm = T)) {
yt$quality3[i] <- "dur less than mean"
} else yt$quality3[i] <- "dur equal mean"
}
# Вариант 3
mtcars$new_var2 <- rep(NA, nrow(mtcars))
for (i in 1:nrow(mtcars)) {
if (mtcars$carb[i] >= 4) {
mtcars$new_var2[i] <- 1
} else if (mtcars$cyl[i] >6){
mtcars$new_var2[i] <- 1
} else mtcars$new_var2[i] <- 0}
ap <- data.frame(AirPassengers)
typeof(AirPassengers)
# Вариант 1
vector1 <- as.vector(AirPassengers)
View(ap)
# Вариант 1
vector1 <- as.vector(AirPassengers)
typeof(vector1)
vector1
vector1[length(vector1)]
length(vector1)
vector1[-length(vector1)]
vector2
# Вариант 1
vector1 <- as.vector(AirPassengers)
vector2 <- c(vector1[length(vector1)],vector1[-length(vector1)])
vector2
diffs <- vector1-vector2
diffs
vector1
vector2
vector1[length(vector1)]
# Вариант 1
vector1 <- as.vector(AirPassengers)
vector2 <- c(vector1[length(vector1)],vector1[-length(vector1)])
diffs <- vector1-vector2
vector1
vector2
diffs
output
output <-  vector1[diffs>0]
good_months <- output
output
# Вариант 2
AP_minus1 <- AirPassengers[1:143]
AP <- AirPassengers[2:144]
good_months1 <- AP[AP - AP_minus1 > 0]
good_months <- c()
index <- 1
for (i in 2:length(AirPassengers)) {
if (AirPassengers[i] > AirPassengers[i-1]){
good_months[index] <- AirPassengers[i]
index <- index + 1
}
}
good_months <- c()
index <- 1
for (i in 2:length(AirPassengers)) {
if (AirPassengers[i] > AirPassengers[i-1]){
good_months[index] <- AirPassengers[i]
index <- index + 1
}
}
ap$good_months <- good_months[index]
View(ap)
moving_average <- numeric(135) # создаем пустой числовой вектор из 135 элементов
last_index <- length(AirPassengers) - 9
moving_average
last_index
end <- i + 9
moving_average[i] <- mean(AirPassengers[i:end])
for (i in 1:last_index) {
end <- i + 9
moving_average[i] <- mean(AirPassengers[i:end])
}
end
moving_average
n <- 10
d <- AirPassengers
cx <- c(0, cumsum(d))
moving_average <- (cx[(n + 1):length(cx)] - cx[1:(length(cx) - n)]) / n
cx
cumsum(d)
AirPassengers
cumsum(d)
cx
remove(list = ls())
install.packages("dplyr")
install.packages("psych")
library(psych)
getwd()
setwd("C:/Users/GudievZK/Desktop/GitHub/DF/")
setwd("/Users/zelimkhan/Desktop/Data/GitHub/DF/")
df  <- mtcars
yt <- read.csv2("yt.csv")
View(df)
View(yt)
str(df)
df$vs  <- factor(df$vs, labels = c("V", "S")) # изменим тип у переменной df$vs с numeric на factor. labels = c("V", "S")
# присваеваем названия урровням фактора.
df$am  <- factor(df$am, labels = c("Auto", "Manual")) # Обратить внимание, что когда мы присваеваем имена мы пишем labels
str(df)
median(df$mpg)
mean(df$disp)
sd(df$hp)
range(df$cyl)
mean_disp  <- mean(df$disp)
mean_disp
mean(df$mpg[df$cyl == 6]) # среднее значение df$mpg у авто, количество цилиндров которых равно 6
mean(df$mpg[df$cyl == 6 & df$vs == "V"]) # среднее значение df$mpg у авто, количество цилиндров которых равно 6 и тип двигателя V
sd(df$hp[df$cyl != 3 & df$am == "Auto"]) # стандартное отклонение у авто, количество цилиндров которых не равно 3 и тип КПП равно автоматическая
# Descriptive statistics
sum(is.na(yt$duration))
mean(yt$duration, na.rm = T)
sd(yt$duration, na.rm = T)
mean(yt$duration[yt$deputy == "Чурсина Мария Вячеславовна" & yt$reason != 'Дорожная карта и план по стандартизации'])
sd(yt$duration[yt$deputy == "Чурсина Мария Вячеславовна" & yt$reason != 'Дорожная карта и план по стандартизации'])
mean(yt$numb_ret_depir[yt$deputy == "Чурсина Мария Вячеславовна" & yt$reason != 'Дорожная карта и план по стандартизации'])
sd(yt$numb_ret_depir[yt$deputy == "Чурсина Мария Вячеславовна" & yt$reason != 'Дорожная карта и план по стандартизации'])
mean(yt$numb_ret_oiv[yt$deputy == "Чурсина Мария Вячеславовна" & yt$reason != 'Дорожная карта и план по стандартизации'])
sd(yt$numb_ret_oiv[yt$deputy == "Чурсина Мария Вячеславовна" & yt$reason != 'Дорожная карта и план по стандартизации'])
## _________________________________________________________________ ##
mean(yt$duration[yt$deputy == "Гудиев Зелимхан Куйраевич"])
mean(yt$duration[yt$deputy == "Чурсина Мария Вячеславовна" & yt$reason != 'Дорожная карта и план по стандартизации'])
sd(yt$duration[yt$deputy == "Гудиев Зелимхан Куйраевич"])
sd(yt$duration[yt$deputy == "Чурсина Мария Вячеславовна" & yt$reason != 'Дорожная карта и план по стандартизации'])
# Вариант 1
df <- mtcars
result <- mean(df$qsec[df$cyl != 3 & df$mpg > 20])
result
mean(yt$duration[yt$year_plan_st == 2020], na.rm = T)
sd(yt$duration[yt$year_plan_st == 2020], na.rm = T)
mean(yt$duration[yt$year_plan_st == 2021], na.rm = T)
sd(yt$duration[yt$year_plan_st == 2021], na.rm = T)
?aggregate
mean_hp_vs  <- aggregate(x = df$hp, by = list(df$vs), FUN = mean) # В ДФ созданном по итогам выполнения функции переменные не имеют наименований
mean_hp_vs
# В ДФ mean_hp_vs у переменных нет наименований
colnames(mean_hp_vs)  <- c("VS", "Mean HP") # укажем наименования переменных
mean_hp_vs
### Вышеуказанные операции можно совершать в сокращенном виде (в виде формулы).###
aggregate(hp ~ vs, df, mean) # В ДФ созданном по итогам выполнения функции переменные имеют наименовани
aggregate(hp ~ vs + am, df, mean)
aggregate(x = df$hp, by = list (df$vs, df$am), FUN = mean) # тоже самое в не сокращенной версии
aggregate(x = df$hp, by = list (df$vs, df$am), FUN = mean)
aggregate(hp ~ vs + am, df, mean) # разбиваем с учетом двух переменных vs + am
aggregate(x = df$hp, by = list (df$vs, df$am), FUN = mean) # тоже самое в не сокращенной версии
### расчитаем ОС для более одной переменной не в сокращенном виде ###
aggregate(x = df[,-c(8,9)], by = list(df$am), FUN = median) # расчитаем ОС не для одной переменной как выше, а для всех количественныз переменных
aggregate(df[,c(1,3)], by = list(df$am, df$vs), FUN = sd) # расчитаем ОС для 1 и 3 переменной с разбиением на группы по тиипу КПП (df$am) и типу двинателя (df$vs)
View(df)
aggregate(cbind(mpg, disp) ~ am + vs, df, sd)
my_stats  <- aggregate(cbind(mpg, disp) ~ am + vs, df, sd) # cbind(mpg, disp) создает лист(?) из двух векторов (переменных)
my_stats
aggregate(yt[, c("duration", "numb_ret_depir", "numb_ret_oiv")], by = list(yt$deputy), FUN = mean)
aggregate(cbind(duration, numb_ret_depir, numb_ret_oiv) ~ deputy, subset(yt,
reason %in% c('План по стандартизации', 'Поручение ДЭПиР или руководства')), mean)
View(yt)
# add a new column
yt <- yt
mutate(tru = case_when(
startsWith(ktd, "П") ~ "Поставка товра",
startsWith(ktd, "В") ~ "Выполнение работ",
startsWith(ktd, "О") ~ "Оказание услуг",
))
library(dplyr)
library(psych)
mutate(tru = case_when(
startsWith(ktd, "П") ~ "Поставка товра",
startsWith(ktd, "В") ~ "Выполнение работ",
startsWith(ktd, "О") ~ "Оказание услуг",
))
# add a new column
yt <- yt
mutate(tru = case_when(
startsWith(yt$ktd, "П") ~ "Поставка товра",
startsWith(yt$ktd, "В") ~ "Выполнение работ",
startsWith(yt$ktd, "О") ~ "Оказание услуг",
))
aggregate(yt[, c("duration", "numb_ret_depir", "numb_ret_oiv")], by = list(yt$tru), FUN = mean)
aggregate(cbind(duration, numb_ret_depir, numb_ret_oiv) ~ tru, subset(yt,
reason %in% c('План по стандартизации', 'Поручение ДЭПиР или руководства')), mean)
aggregate(cbind(duration, numb_ret_depir, numb_ret_oiv) ~ tru, subset(yt,
reason %in% c('План по стандартизации', 'Поручение ДЭПиР или руководства')), mean)
