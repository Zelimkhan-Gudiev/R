is_maried  <- c(F, F, T, T)
is_maried  <- c(F, F, T, T)
name  <- c("Olga", "Maria", "Nastya", "Polina")
age  <- c(16, 18, 22, 27)
my_data  <- data.frame(Name = name, Age = age, Status = is_maried)
my_data
View(my_data)
typeof(my_data) # list, т.к. данный дф содержит данные разного типа
typeof(my_data$Status) # list, т.к. данный дф содержит данные разного типа
#
my_vector <- 1:10
mean(my_vector)
sd(my_vector)
mean(my_vector) - sd(my_vector) # нижняя граница
mean(my_vector) + sd(my_vector)
my_vector[my_vector > mean(my_vector) - sd(my_vector) & my_vector < mean(my_vector) + sd(my_vector)]
5 %% 2
# + сложение
# - вычитание
# * умножение
# / деление  (5 / 2 = 2.5)
# ^ или **  возведение в степень (5^2 = 25 или 5**2 = 25)
# x %% y остаток от деления
5 %% 3  # 5 %% 2 = 1
# + сложение
# - вычитание
# * умножение
# / деление  (5 / 2 = 2.5)
# ^ или **  возведение в степень (5^2 = 25 или 5**2 = 25)
# x %% y остаток от деления
5 %% 5  # 5 %% 2 = 1
# + сложение
# - вычитание
# * умножение
# / деление  (5 / 2 = 2.5)
# ^ или **  возведение в степень (5^2 = 25 или 5**2 = 25)
# x %% y остаток от деления
5 %% 2  # 5 %% 2 = 1
4 %% 2
1 %% 2
2 %% 4
my_data <- read.csv('https://stepik.org/media/attachments/lesson/11481/evals.csv')
yt <- read.csv2("yt.csv")
remove(list = ls())
my_data <- read.csv('https://stepik.org/media/attachments/lesson/11481/evals.csv')
yt <- read.csv2("yt.csv")
yt <- read.csv2("yt.csv")
#### Reading data _____________________________________________________________________________________________________________________________ ####
getwd()
setwd("/Users/zelimkhan/Desktop/Data/GitHub/DF/")
ls
my_data <- read.csv('https://stepik.org/media/attachments/lesson/11481/evals.csv')
yt <- read.csv2("yt.csv")
View(my_data)
summary(yt$duration)
my_data$score # выводит вектор значений переменной score
b <- my_data$score # вектор значений можно присвоить объектьу b
mean(my_data$score) # т.к. переменная в дата фрейме является вектром, то с данной переменной можно выполнять все операции доступные для векторов,
# для векторов, например, расчитать ср. значение
summary(my_data$score) # можно применить функцию саммари для расчета описательных статистик
my_data$score*2
my_data$score
4.7*2
my_data$ten_point_scale <- my_data$score*2 # Если после знака $ указать не существующую переменную,
View(my_data)
summary(my_data$ten_point_scale)
# для векторов, например, расчитать ср. значение
summary(my_data$score) # можно применить функцию саммари для расчета описательных статистик
summary(my_data$ten_point_scale)
my_data$new_variable <- 0 # создадим новую переменную, все значения которой содержат нули
my_data$number <- 1:nrow(my_data) # создадим новую переменную, содержащую порядкоый номер строки (наблюдения).
1:nrow(my_data)
# Номер строки задается вектором значений "1:nrow(my_data)" от "1" до количество количества строк в my_data
summary(my_data$number)
nrow(my_data) # возвращает количество строк в дата фрейме
ncol(my_data) # возвращает количество столбцов в дата фрейме
yt$teamleader
my_data$score[1:10] # обращение к первым десяти значениям переменной (вектора) my_data$score с помошью индекс [ ]
# индексы [ ] можно задавать разными способоми. В индексе [ ] можно указывать вектор или логическое значение и т.д.
my_data[1,1] # т.к. дата фрейм является двумерным объектом, то можно обратиться к любому его элементу указав два индекса.
my_data[c(2,193,225),1] # в идексе до запятой указываются строки, а после запятой столбцы
my_data[101:200,1]
my_data[5,] # если не указать индекс переменной, то это значит, что для нам не важен и мы хотим посмотреть значения всех переменных.
View(my_data[5,])
# С помощью данной строки мы обращаемся к пятой строке нашего дата фрейма со всеми столбцами.
my_data[, 1] # можно обратиться к первому стобцу. В таком случае мы увидим все значения первой переменной (столбца).
View(my_data[, 1])
View(my_data[, 1])
my_data[, 1] == my_data$score
my_data[, 2:5]
View(my_data[, 2:5])
View(yt[c(1:5), c(2,3)])
yt[c(1:5), c(2,3)]
my_data$gender
my_data$gender == 'female'
my_data[,1]
my_data[my_data$gender =='female', 1]
####  ####
read.csv2("2022.05.17 size st (mac).csv")
####  ####
zakupki <- read.csv2("2022.05.17 size st (mac).csv")
View(zakupki)
sum(zakupki$KPGZ_SUM)
sum(zakupki$KPGZ_SUM)
sum(zakupki$KPGZ_SUM)
####  ####
zakupki <- read.csv2("2022.05.17 size st (mac).csv")
str(zakupki)
sum(zakupki$KPGZ_SUM)
7.082731*10^12
10^12
sum(zakupki$KPGZ_SUM[zakupki$status == 1])
sum(zakupki$KPGZ_SUM[zakupki$status == c(1, 2, 3)]) # 688 млрд 780 млн 000 000 руб.
sum(zakupki$KPGZ_SUM[zakupki$status %in% c(1, 2, 3)]) # 688 млрд 780 млн 000 000 руб.
sum_St_3step_22/sum_3step_22*100
sum_3step_22 <- 996712017498.52 # Сумма закупок по 44-ФЗ и 223-ФЗ на 3 этапе = 996.712.017.498
sum_St_3step_22 <- 736904596172.16 # Сумма стандартизированных закупок по 44-ФЗ и 223-ФЗ = 736.904.596.172
dolya_St_3step <- sum_St_3step_22/sum_3step_22*100 #
dolya_St_3step
my_data[my_data$gender == 'female', 1:3]
View(my_data[my_data$gender == 'female', c(1:3)])
# В R есть функция, которая позволяет нам обращается к .. данным без индексации
subset(my_data, gender == 'female') # в качестве условия указана факторная перменная gender
View(subset(my_data, gender == 'female'))
subset(zakupki, status %in% c(1, 2, 3))
View(subset(zakupki, status %in% c(1, 2, 3)))
sum(subset(zakupki, status %in% c(1, 2, 3)))
stand <- subset(zakupki, status %in% c(1, 2, 3))
sum(stand$)
sum(stand$KPGZ_SUM)
View(subset(my_data, gender == 'female'))
yt[yt$duration > mean(yt$duration, na.rm = T), 3]
yt[yt$deputy == "Гудиев Зелимхан Куйраевич", 3]
yt[yt$deputy == "Гудиев Зелимхан Куйраевич" & yt$duration > mean(yt$duration, na.rm = T), 3]
View(yt[yt$deputy == "Гудиев Зелимхан Куйраевич" & yt$duration > mean(yt$duration, na.rm = T), c(1:3)])
yt[yt$duration > mean(yt$duration, na.rm = T), 3]
View(yt)
yt[yt$deputy == "Гудиев Зелимхан Куйраевич" & yt$duration > mean(yt$duration, na.rm = T), 3]
View(yt[yt$deputy == "Гудиев Зелимхан Куйраевич" & yt$duration > mean(yt$duration, na.rm = T), c(1:3)])
View(subset(yt, deputy == "Гудиев Зелимхан Куйраевич"))
#### rbind, cbind (rowbind - соединение по строкам, columnbind - соединение по столбцам) _____________________________________________________ ####
# rbind (rowbind) - соединяет два дата фрейма по строкам
# для демонтрации того, что делает функция rbind создадим два дата фрейма my_data2, my_data3
my_data2 <- subset(my_data, gender == 'female') # дата фрейм my_data2 будет содержать только те наблюдения где преподователь женщина
my_data3 <- subset(my_data, gender == 'male') # дата фрейм my_data3 будет содержать только те наблюдения где преподователь мужчина
my_data2
my_data4 <- rbind(my_data2, my_data3) # rbind соединяет два дата фрейма с одиновым количеством столбцов (наименования столбцов должны совпадать)
View(my_data2)
View(my_data3)
View(my_data2)
View(my_data4)
my_data[, 1:10]
library(help = 'datasets')
mtcars # Команда mtcars выводит данные в консоли
data(mtcars) # Команда data(mtcars) добавит датасет в рабочую среду
help(mtcars) # Команда help(mtcars) выведет информацию о датасете (?mtcars)
mydata <- mtcars # Команда my_data <- mtcars запишет датасет в новую переменную
View(mtcars)
#### Step 7 of 11. Задача _____________________________________________________________________________________________________________________ ####
# В этой задче поработаем со встроенными данными mtcars. В датафрэйме mtcars создайте новую колонку (переменную)
# под названием even_gear, в которой будут единицы, если значение переменной (gear) четное, и нули если количество нечетное.
# Подсказка: вам может помочь оператор деления с остатком:5 %% 2 == 1 TRUE
5 %% 2 == 1
my_data[, 1]
#### Step 7 of 11. Задача _____________________________________________________________________________________________________________________ ####
# В этой задче поработаем со встроенными данными mtcars. В датафрэйме mtcars создайте новую колонку (переменную)
# под названием even_gear, в которой будут единицы, если значение переменной (gear) четное, и нули если количество нечетное.
# Подсказка: вам может помочь оператор деления с остатком:5 %% 2 == 1 TRUE
5 %% 2 == 1
#### Step 7 of 11. Задача _____________________________________________________________________________________________________________________ ####
# В этой задче поработаем со встроенными данными mtcars. В датафрэйме mtcars создайте новую колонку (переменную)
# под названием even_gear, в которой будут единицы, если значение переменной (gear) четное, и нули если количество нечетное.
# Подсказка: вам может помочь оператор деления с остатком:5 %% 2 == 1 TRUE
5 %% 2
4 %% 2
# Решения
# Вариант 1
mtcars$even_gear <- ifelse (mtcars$gear %% 2 == 1, 0, 1) # если остаток деления значения переменной mtcars$gear на 2 равно 1,
# Варинат 2
mtcars$even_gear1 <- (mtcars$gear+1) %% 2
mtcars$even_gear1
# Вариант 3
mtcars$even_gear2[mtcars$gear%%2 == 0] <- 1 # если остаток деления значения переменной mtcars$gear на 2 равно 0,
# то запиши в mtcars$even_gear2 значение 1. Четное - 1
mtcars$even_gear2[mtcars$gear%%2 == 1] <- 0 # если остаток деления значения переменной mtcars$gear на 2 равно 1,
# Вариант 4
data('mtcars')
a <- mtcars$gear # создадим переменную a и запишем в нее значения перменной mtcars$gear
a
even <- subset(mtcars, a%%2 == 0) # создадим дата фрейм even и сохраним в нем сабсет данных, значения переменной
View(even)
# a <- mtcars$gear отвечает условию: остаток деления а на 2 равен 0 (a%%2 == 0), т.е. четные значения
even$even_gear <- 1 # создадим в днном дата фрейме новую переменную even$even_gear и запишим в нее значение 1
uneven <- subset(mtcars, a%%2 == 1)  # создадим дата фрейм uneven и сохраним в нем сабсет данных, значения переменной a <- mtcars$gear
View(even)
uneven <- subset(mtcars, a%%2 == 1)  # создадим дата фрейм uneven и сохраним в нем сабсет данных, значения переменной a <- mtcars$gear
View(uneven)
# отвечает условию: остаток деления а на 2 равен 1 (a%%2 == 1), т.е. нечетные значения
uneven$even_gear <- 0 # создадим в днном дата фрейме новую переменную even$even_gear и запишим в нее значение 0
r
mtcars <- rbind(even, uneven) # соединим два дата фрема по строкам
mtcars
sort(zakupki)
View(zakupki)
View(zakupki)
# Вариант 3
mpg_4 <- mtcars[mtcars$cyl == 4, "mpg"]
mpg_4
View(mtcars)
sort(yt[yt$deputy == "Гудиев Зелимхан Куйраевич", "duration"])
# Вариант 4
mpg_4 <- subset(mtcars, cyl == 4)$mpg
mpg_4
View(mtcars[, c(mtcars$cyl, mtcars$mpg])
View(mtcars[, c('cyl', 'mpg'])
View(mtcars[, c('cyl', 'mpg']))
View(mtcars[, c('cyl', 'mpg']))
mtcars[, c('cyl', 'mpg']
View(mtcars[, c(mtcars$cyl, mtcars$mpg]))
View(mtcars[, c(mtcars$cyl, mtcars$mpg)])
mtcars[, c(mtcars$cyl, mtcars$mpg)]
mtcars[, c('cyl', 'mpg']
mtcars[, c('cyl', 'mpg')]
View(mtcars[, c('cyl', 'mpg')])
View(mtcars[, c(mtcars$cyl, mtcars$mpg)])
mtcars[, c(mtcars$cyl, mtcars$mpg)]
# Вариант 1
mpg_4.1 <- mtcars$mpg[mtcars$cyl == 4]
mpg_4.1
mpg_4.2
# Вариант 2
s <-subset(mtcars, cyl == 4)
mpg_4.2 <- s$mpg
mpg_4.2
# Вариант 3
mpg_4 <- mtcars[mtcars$cyl == 4, "mpg"]
mpg_4
mtcars$mpg[mtcars$cyl == 4]
# Вариант 2
s <-subset(mtcars, cyl == 4)
s
mtcars[mtcars$cyl == 4, "mpg"]
# Вариант 6
mpg_4 <-mtcars[mtcars$cyl == '4', 1]
mpg_4
remove(list = ls())
mydata <-  read.csv("/Users/zelimkhan/Desktop/evals.csv") # не работает
mydata <- read.csv('evals.csv')
yt <- read.csv2('yt.csv') # Отступление
# принимает на вход условие (одно логическое значение), что выдает на выходе TRUE or FALSE
# оператор if: 1) принимает на вход условие; 2) затем проверяет выполняется ли данное условие;
# 3) если выполняестя, то выполняет некоторую комманду; 4) если условие не выполняется то выполняет другую комманду
a <- -10
# два варианта
if (a > 0) { # 1) принимает на вход условие if (a > 0); 2) затем проверяет выполняется ли данное условие;
print('positive') # 3) если выполняестя, то выполняет некоторую комманду print('positive');
} else('not positive') # 4) если условие не выполняется то выполняет другую комманду else('not positive');
# два варианта + действие (a + 1)
if (a > 0) {
print('positive')
} else { # Если после else не использовать фигурные скобки { } то мы сможем выполнить только одно действие print('not positive'). Если хотим выполнить более одного действия, нужно использовать фигурные скобки { }
print('not positive')
print(a + 1) # + действие (a + 1)
}
# три варианта
if (a > 0) {
print('positive')
} else if (a < 0) {
print('negative')
} else print('zero')
#### yt (if) __________________________________________________________________________________________________________________________________ ####
# Warning messages:
# В отличии от ifelse операторр if не позволяет работать с векторами произвольной длины.
# при выполнении нижеуказанной функции будет выдано только одно значение ("positive") для первого значения вектора a <- c(1, -1), т.е. для 1
if (yt$duration < mean(yt$duration, na.rm = T)) {
print('dur_less_than_mean')
} else if (yt$duration > mean(yt$duration, na.rm = T)) {
print('dur_more_than_mean')
} else print('dur_equal_mean')
ifelse(a > 0, 'positive', 'not positive')
a <- c(1, -1) # ifelse позволяет работать с векторами произвольной длины. В данном случае длина вектора а равняется двум a <- c(1, -1)
ifelse(a > 0, 'positive', 'not positive') # в данном случае ifelse выдает два значения 'positive' и 'not positive'
# В отличии от ifelse операторр if не позволяет работать с векторами произвольной длины.
# при выполнении нижеуказанной функции будет выдано только одно значение ("positive") для первого значения вектора a <- c(1, -1), т.е. для 1
a <- c(1, -1)
# В отличии от ifelse операторр if не позволяет работать с векторами произвольной длины.
# при выполнении нижеуказанной функции будет выдано только одно значение ("positive") для первого значения вектора a <- c(1, -1), т.е. для 1
a <- c(1, -1)
if (a > 0) {
print('positive')
} else if (a < 0) {
print('negative')
} else print('zero')
#### yt (felse) _______________________________________________________________________________________________________________________________ ####
# error
ifelse(yt$duration <= mean(yt$duration, na.rm = T), "dur less than mean/dur equal mean ","dur more than mean")
less_or_equal_or_more_than_mean <- ifelse(yt$duration <= mean(yt$duration, na.rm = T), "dur less than mean/dur equal mean","dur more than mean")
less_or_equal_or_more_than_mean
length(less_or_equal_or_more_than_mean[less_or_equal_or_more_than_mean == 'dur more than mean'])
length(less_or_equal_or_more_than_mean[less_or_equal_or_more_than_mean == "dur less than mean/dur equal mean"])
mean(yt$duration, na.rm = T)
length(yt[yt$duration == 130.2266])
# оператор for на вход должен получать вектор значений in 1:10
# цикл for позволяет выполнять много раз рутинную операцию (с каждым элементом вектора)
for (i in 1:10) {
print(i)
}
# for делает следующее: i пробегает значения от 1 до количества строк в дата фрейме и выводит значения yt$duration из i строки
for(i in 1:nrow(yt)) {
print(yt$duration[i])
}
for(i in 1:nrow(yt)) {
print(yt$ktd[i])
}
for (i in 1:nrow(mydata)) {
print(mydata$score[i])
}
for (i in 1:nrow(mydata)) {           # for принимает на вход вектор. Вектор от 1 до количества строк в mydata
if (mydata$gender[i] == 'male') {   # if принимает на вход вектор и условие. Если i значние mydata$gender[i] равно 'male'
print(mydata$score[i])            # print(mydata$score[i] выводит i значние переменной score. Выводит значние переменной score для всех строк где значние mydata$gender[i] равно 'male' по всем строкам от 1 до nrow(mydata)
}
}
for(i in 1:nrow(yt)) {
if(yt$numb_ret_depir[i] > 5) {
print(yt$name[i])
}
}
for(i in 1:nrow(yt)) {
if(yt$numb_ret_depir[i] > 3) {
ksk <- data.frame(yt$name[i], yt$teamleader[i], yt$numb_ret_depir[i])
}
}
View(ksk)
View(yt)
mydata$quality <- rep(NA, nrow(mydata)) # Создадим новую переменную quality с пустыми значениями и длиной nrow(mydata).
View(mydata)
for (i in 1:nrow(mydata)) {             # задаем вектор, который должен пробегать оператор for
if (mydata$score[i] > 4){             # задаем условия для операторра if. Проверяем в i строке mydata$score больше 4
mydata$quality[i] <- 'good'         # указываем действие, которое необходимо выполнить если условие выполнено. Если в i строке значение mydata$score больше 4, то в этой i строке в столбце mydata$quality записываем значение 'good'
} else mydata$quality[i] <- 'bad'     # указываем действие, которое необходимо выполнить если условие не выполнено. Если в i строке значение mydata$score не больше 4, то в этой i строке в столбце mydata$quality записываем значение 'bad'
}
View(yt)
yt$quality <- rep(NA, nrow(yt))
for (i in 1:nrow(yt)) {
if (yt$duration[i] > mean(yt$duration, na.rm = T)) {
yt$quality[i] <- "dur more than mean"
} if (yt$duration[i] < mean(yt$duration, na.rm = T)) {
yt$quality[i] <- "dur less than mean"
} else yt$quality[i] <- "dur equal mean"
}
for (i in 1:nrow(yt)) {
if (yt$duration[i] > mean(yt$duration, na.rm = T)) {
yt$quality[i] <- "dur more than mean"
} if (yt$duration[i] < mean(yt$duration, na.rm = T)) {
yt$quality[i] <- "dur less than mean"
} else yt$quality[i] <- "dur equal mean"
}
# error
length(yt$quality[yt$quality == "dur more than mean"])
length(yt$quality[yt$quality == "dur less than mean"])
length(yt$quality[yt$quality == "dur equal mean"])
59+70
# yt
yt$quality2 <-  ifelse(yt$duration > mean(yt$duration, na.rm = T), "dur more than mean", "dur less than mean/dur equal mean")
# альтенативный способ
View(subset(zakupki, status %in% c(1, 2, 3)))
# альтенативный способ
View(subset(zakupki, status %in% c(1, 2, 3)))
i <- 1
while (i < 51) {            # оператор while будет выполнять нижеуказанные действия до тех пор пока i < 51, т.е с 1 до 51-й строки
print(mydata$score[i])    # если i < 51, то выводим значение столбца mydata$score и так до тех пор пока (i < 51)
i <- i + 1                # если i < 51, то добавляем 1 к i (i + 1) и так до тех пор пока (i < 51)
}
# yt
yt$score <- ifelse((yt$numb_ret_depir >= 4 | yt$numb_ret_oiv >= 4), 'Bad', 'Norm') # отсупление
yt$score
length(yt$score[yt$score == 'Bad'])
length(yt$score[yt$score == 'Norm'])
# Вариант 2
for (i in 1:nrow(mtcars)){
if (mtcars$carb[i] >= 4  |  mtcars$cyl[i] > 6){
mtcars$new_var1[i] = 1
}
else mtcars$new_var1[i] = 0
}
# yt
yt$quality3 <- rep(NA, nrow(yt))
for (i in i:nrow(yt)) {
if (yt$duration[i] > mean(yt$duration, na.rm = T)) {
yt$quality3[i] <- "dur more than mean"
} if (yt$duration[i] < mean(yt$duration, na.rm = T)) {
yt$quality3[i] <- "dur less than mean"
} else yt$quality3[i] <- "dur equal mean"
}
for (i in 1:nrow(yt)) {
yt$quality3[i] <- "dur more than mean"
if (yt$duration[i] > mean(yt$duration, na.rm = T)) {
yt$quality3[i] <- "dur more than mean"
} if (yt$duration[i] < mean(yt$duration, na.rm = T)) {
yt$quality3[i] <- "dur less than mean"
} else yt$quality3[i] <- "dur equal mean"
for (i in 1:nrow(yt)) {
if (yt$duration[i] > mean(yt$duration, na.rm = T)) {
yt$quality3[i] <- "dur more than mean"
} if (yt$duration[i] < mean(yt$duration, na.rm = T)) {
yt$quality3[i] <- "dur less than mean"
} else yt$quality3[i] <- "dur equal mean"
}
ap <- data.frame(AirPassengers)
typeof(AirPassengers)
View(ap)
# Вариант 1
vector1 <- as.vector(AirPassengers)
vector1
View(ap)
vector2 <- c(vector1[length(vector1)],vector1[-length(vector1)])
vector2
vector1[length(vector1)]
View(ap)
vector1[-length(vector1)]
vector1-vector2
diffs <- vector1-vector2
vector1
vector2
vector1
vector2
diffs
112 - 432
diffs <- vector1-vector2
output = vector1[diffs>0]
output
vector1[length(vector1)]
vector1
vector2
diffs <- vector1-vector2
output <-  vector1[diffs>0]
good_months <- output
good_months
AirPassengers
vector1
# Вариант 2
AP_minus1 <- AirPassengers[1:143]
AirPassengers
AP_minus1
AP <- AirPassengers[2:144]
good_months1 <- AP[AP - AP_minus1 > 0]
good_months1
AirPassengers[-1]
AirPassengers
index <- 1
for (i in 2:length(AirPassengers)) {
if (AirPassengers[i] > AirPassengers[i-1]){
good_months[index] <- AirPassengers[i]
index <- index + 1
}
}
for (i in 2:length(AirPassengers)) {
if (AirPassengers[i] > AirPassengers[i-1]){
good_months[index] <- AirPassengers[i]
index <- index + 1
}
}
for (i in 2:length(AirPassengers)) {
if (AirPassengers[i] > AirPassengers[i-1]){
good_months[index] <- AirPassengers[i]
index <- index + 1
}
}
ap$good_months <- good_months[index]
ap$good_months
ap$good_months <- good_months[index]
good_months[index]
length(AirPassengers) - 9
mean(AirPassengers[i:end])
i + 9
i
moving_average <- numeric(135) # создаем пустой числовой вектор из 135 элементов
last_index <- length(AirPassengers) - 9
for (i in 1:last_index) {
end <- i + 9
moving_average[i] <- mean(AirPassengers[i:end])
}
AirPassengers
d
d <- AirPassengers
d
c(0, cumsum(d))
112+118
230+112
230+118
cumsum(d)
AirPassengers
cumsum(d)
112+118
230+
362-232
230+
362-232
230+
362 - 232
362 - 232
AirPassengers
moving_average <- numeric(135)
for (i in 1:135) {
moving_average[i] <- sum(AirPassengers[i:(i+9)])/10
remove(list = ls())
remove(list = ls())
remove(list = ls())
remove(list = ls())
remove(list = ls())
mydata <-  read.csv("/Users/zelimkhan/Desktop/evals.csv") # не работает
remove(list = ls())
