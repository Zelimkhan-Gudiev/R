remove(ls = list())
remove(list = ls())
#### Exercise 1 (page 212) ####
# Некоторые исследования выявили слабую положительную связь между ростом и умственными способностями, то есть более высокие люди
# в среднем немного умнее. Использую формулы, представленные в этой главе,
# рассчитайте коэффициент корреляции Пирсона для данных представленных в таблице 7.2
# Затем проверьте корреляцию на статистическую значимость (проведите двухсторонний тест с уровнем значимости 0,05),
# рассситайте коэффициент детерминации и проанализируйте результаты
# Таблицы 7.2
student <- c(1:10)
height_inch <- c(60, 62, 63, 65, 65, 67, 68, 70, 70, 71)
iq <- c(103, 100, 98, 95, 110, 108, 104, 110, 97, 100)
table_7.2 <- data.frame(student, height_inch, iq)
View(table_7.2)
cor.test(height_inch, iq)
0.1347945 * sqrt(10 - 2)/sqrt(1 - 0.1347945^2)
# 3) Рассситайте коэффициент детерминации и проанализируйте результаты
0.1347945^2
0.1347945^2
# альтернативный способ
ssx <- sum(height_inch - mean(height_inch)
sum(height_inch - mean(height_inch)
sum(height_inch - mean(height_inch))
sum(c(60, 62, 63, 65, 65, 67, 68, 70, 70, 71) - mean(c(60, 62, 63, 65, 65, 67, 68, 70, 70, 71)))
sum(iq - mean(iq))
sum(c(103, 100, 98, 95, 110, 108, 104, 110, 97, 100) - mean(c(103, 100, 98, 95, 110, 108, 104, 110, 97, 100)))
sum((height_inch - mean(height_inch)) * (iq - mean(iq)))
sum(
(
c(60, 62, 63, 65, 65, 67, 68, 70, 70, 71) - mean(c(60, 62, 63, 65, 65, 67, 68, 70, 70, 71)
)
*
(
c(103, 100, 98, 95, 110, 108, 104, 110, 97, 100) - mean(c(103, 100, 98, 95, 110, 108, 104, 110, 97, 100))
)
)
sum(
(
c(60, 62, 63, 65, 65, 67, 68, 70, 70, 71) - mean(c(60, 62, 63, 65, 65, 67, 68, 70, 70, 71))
)
*
(
c(103, 100, 98, 95, 110, 108, 104, 110, 97, 100) - mean(c(103, 100, 98, 95, 110, 108, 104, 110, 97, 100))
)
)
sum(
(
c(60, 62, 63, 65, 65, 67, 68, 70, 70, 71) - mean(c(60, 62, 63, 65, 65, 67, 68, 70, 70, 71))
)
*
(
c(103, 100, 98, 95, 110, 108, 104, 110, 97, 100) - mean(c(103, 100, 98, 95, 110, 108, 104, 110, 97, 100))
)
)
sum((height_inch - mean(height_inch)) * (iq - mean(iq)))
ssx <- sum(height_inch - mean(height_inch))
ssx <- sum(c(60, 62, 63, 65, 65, 67, 68, 70, 70, 71) - mean(c(60, 62, 63, 65, 65, 67, 68, 70, 70, 71)))
ssy <- sum(iq - mean(iq))
ssy <- sum(c(103, 100, 98, 95, 110, 108, 104, 110, 97, 100) - mean(c(103, 100, 98, 95, 110, 108, 104, 110, 97, 100)))
ssxy <- sum((height_inch - mean(height_inch)) * (iq - mean(iq)))
ssxy <- sum(
(
c(60, 62, 63, 65, 65, 67, 68, 70, 70, 71) - mean(c(60, 62, 63, 65, 65, 67, 68, 70, 70, 71))
)
*
(
c(103, 100, 98, 95, 110, 108, 104, 110, 97, 100) - mean(c(103, 100, 98, 95, 110, 108, 104, 110, 97, 100))
)
)
r = ssxy/sqrt(ssx * ssy)
r
r <- ssxy/sqrt(ssx * ssy)
r
cor.test(height_inch, iq)
ssxy
ssx
ssy
ssy
r <- 24.5/sqrt(5.684342e-14 * 0)
r
cor.test(height_inch, iq)
ssxy
sum((height_inch - mean(height_inch)) * (iq - mean(iq)))
sum(height_inch - mean(height_inch))
sum((height_inch - mean(height_inch))^2)
sum(
(
c(60, 62, 63, 65, 65, 67, 68, 70, 70, 71) - mean(c(60, 62, 63, 65, 65, 67, 68, 70, 70, 71))
)^2
)
sum(
(
iq - mean(iq)
)^2
)
sum(
(
c(103, 100, 98, 95, 110, 108, 104, 110, 97, 100) - mean(c(103, 100, 98, 95, 110, 108, 104, 110, 97, 100))
)^2
)
# ssx
ssx <- sum(
(
height_inch - mean(height_inch)
)^2
)
ssx <- sum(
(
c(60, 62, 63, 65, 65, 67, 68, 70, 70, 71) - mean(c(60, 62, 63, 65, 65, 67, 68, 70, 70, 71))
)^2
)
# ssy
ssy <- sum(
(
iq - mean(iq)
)^2
)
ssy <- sum(
(
c(103, 100, 98, 95, 110, 108, 104, 110, 97, 100) - mean(c(103, 100, 98, 95, 110, 108, 104, 110, 97, 100))
)^2
)
# ssxy
ssxy <- sum((height_inch - mean(height_inch)) * (iq - mean(iq))) # 24.5
ssxy/sqrt(ssx * ssy)
r <-  ssxy/sqrt(ssx * ssy)
r
ssxy
ssx
ssy
24.5/sqrt(124.9 * 264.5)
ssxy/sqrt(ssx * ssy)
cor.test(height_inch, iq)
r * sqrt(n - 2)/sqrt(1 - r^2)
n <- 10
t <-  r * sqrt(n - 2)/sqrt(1 - r^2)
r * sqrt(n - 2)/sqrt(1 - r^2)
cor.test(height_inch, iq)
r * sqrt(n - 2)/sqrt(1 - r^2)
sum(height_inch)
sum(height_inch^2)
sum(iq)
sum(iq^2)
sum(c(height_inch, iq))
sum(c(height_inch*iq))
install.packages("rgoogleads")
install.packages("googlesheets4")
library(googlesheets4)
library(googlesheets4)
sheets_auth(email = 'gudievzk@gmail.com')
# lib
library(googlesheets4)
# авторизация
sheets_auth(email = "selesnow@gmail.com")
# данные для теста
my_iris   <- iris
my_mtcars <- mtcars
# создаём докс
ss <- sheets_create("demo_dox",
sheets = list(iris   = head(my_iris),
mtcars = my_mtcars))
# открыть созданный Google Dox
sheets_browse(ss)
# создать новый лист
sheets_sheet_add(ss,
sheet = "mtcars_new",
.after = "mtcars")
gs4_auth(email = 'GudievZK@gmail.com')
remove(list = ls())
# lib
library(googlesheets4)
# данные для теста
my_iris   <- iris
my_mtcars <- mtcars
# создаём докс
ss <- sheets_create("demo_dox",
sheets = list(iris   = head(my_iris),
mtcars = my_mtcars))
# создаём докс
ss <- gs4_create("demo_dox",
sheets = list(iris   = head(my_iris),
mtcars = my_mtcars))
# открыть созданный Google Dox
gs4_browse(ss)
# создать новый лист
sheet_add(ss,
sheet = "mtcars_new",
.after = "mtcars")
# запись данных на новый лист
sheet_write(data = my_iris,
ss = ss,
sheet = "iris_new")
# дописать значиения
sheet_append(data  = tail(my_iris, 20),
ss    = ss,
sheet = "iris")
# получить список листок google таблицы
sheet_names(ss)
# чтение листа из гугл таблиц
ss2 <- as_sheets_id("17dRz4AYgfQvpTI6J6p9AYjrVuC-gTRj7BM4MzgAxIKY")
ss2
data <- sheets_read(ss2,
sheet = "iris_new")
# чтение листа из гугл таблиц
dolya <- as_sheets_id("1VOKDMjL2LoasWjF7w1kSkKz71VyVDr03")
dolya <- sheets_read(dolya,
sheet = "dolya")
dolya <- sheet_read(dolya,
sheet = "dolya")
dolya <- read_sheet(dolya,
sheet = "dolya")
dolya
# чтение листа из гугл таблиц
dolya <- as_sheets_id("1VOKDMjL2LoasWjF7w1kSkKz71VyVDr03")
dolya <- read_sheet(dolya,
sheet = "dolya")
# чтение листа из гугл таблиц
dolya <- as_sheets_id("1VOKDMjL2LoasWjF7w1kSkKz71VyVDr03")
dolya <- read_sheet(dolya,
sheet = "Export Worksheet")
dolya
dolya <- read_sheet(dolya,
sheet = "Export Worksheet")
dolya_s <- read_sheet(dolya,
sheet = "Export Worksheet")
# чтение листа из гугл таблиц
dolya <- as_sheets_id("1VOKDMjL2LoasWjF7w1kSkKz71VyVDr03")
dolya_s <- read_sheet(dolya,
sheet = "Export Worksheet")
# чтение листа из гугл таблиц
dolya <- as_sheets_id("1VOKDMjL2LoasWjF7w1kSkKz71VyVDr03")
dolya_s <- read_sheet(dolya,
sheet = "Export Worksheet")
dolya_s <- range_read(dolya, shett = "Export Worksheet")
dolya_s <- range_read(dolya, sheet = "Export Worksheet")
# чтение листа из гугл таблиц
dolya <- as_sheets_id("1_HvhGAXsk2_s161Jmv01emFqmKaEr3aZ")
dolya_s <- read_sheet(dolya,
sheet = "Export Worksheet")
dolya_s <- range_read(dolya, sheet = "Export Worksheet")
# чтение листа из гугл таблиц
dolya <- as_sheets_id("1ltR2wYrmN1tPla6TJfvpvG-IwInB_43Gth_4Ywws5S8")
dolya_s <- read_sheet(dolya,
sheet = "Export Worksheet")
dolya_s <- range_read(dolya, sheet = "Export Worksheet")
View(dolya_s)
dolya <- range_read(dolya, sheet = "Export Worksheet")
names(dolya)
delAndSt <- subset(dolya, IS_STANDARD_PRODUCT == 2)
View(delAndSt)
condStand <- subset(dolya, IS_STANDARD_PRODUCT %in% c(2, 4, 5, 51, 6))
View(condStand)
cor(iris[, -5])
positive_sum <- function(x) {
lapply(x, function (x) {sum(x[!is.na(x) & x > 0])})
}
positive_sum
positive_sum(x)
remove(list = ls())
x <- data.frame(matrix(rnorm(30), ncol = 6))
View(x)
positive_sum <- function(x) {
positive_sum <- function(x) {
lapply(x, function (x) {sum(x[!is.na(x) & x > 0])})
}
positive_sum <- function(x) {
lapply(x, function (x) {sum(x[!is.na(x) & x > 0])})
}
positive_sum <- function(x) {
lapply(x, function (x) {sum(x[!is.na(x) & x > 0])})
}
positive_sum <- function(x) {
lapply(x, function(x) {
sum(x[!is.na(x) & x > 0])
})
}
positive_sum <- function(x) {
lapply(x, function(x) {
sum(x[!is.na(x) & x > 0])
})}
positive_sum <- function(x) {lapply(x, function(x) {sum(x[!is.na(x) & x > 0])})}
positive_sum <- function(x) {
positive_sum <- function(x) {lapply(x, function(x) {sum(x[!is.na(x) & x > 0])})}
positive_sum <- function(x) {lapply(x, function(x) {sum(x[!is.na(x) & x > 0])})}
positive_sum(x)
x <- data.frame(matrix(rnorm(30), ncol = 6))
positive_sum(x)
remove(list = ls())
positive_sum <- function(x) {lapply(x, function(x) {sum(x[!is.na(x) & x > 0])})}
test_data <- data.frame(matrix(rnorm(30), ncol = 6))
positive_sum <- function(test_data) {lapply(test_data, 2, function(x) {sum(x[!is.na(x) & x > 0])})}
positive_sum(x)
positive_sum <- function(test_data) {lapply(test_data, function(x) {sum(x[!is.na(x) & x > 0])})}
positive_sum(x)
positive_sum(xtest_data)
positive_sum <- function(test_data) {lapply(test_data, function(x) {sum(x[!is.na(x) & x > 0])})}
positive_sum(xtest_data)
positive_sum(test_data)
iris[sapply(iris, is.numeric)]
iris_num <- iris[sapply(iris, is.numeric)]
iris_num
sapply(iris, is.numeric)
sapply(iris[1:4], sd)
apply(iris[1:4], 2, sd)
# так как каждая колонка dataframe - это и есть элемент списка, то функция lapply и sapply возвращает результат применения некоторой функции
# к каждой колонке данных!
# Но тут есть одно но!
# Как вы помните, apply производит все опперации именно над матрицами, поэтому если вы отправите в apply dataframe с разными типами данных,
# то R сначала приведет все колонки к одному типу, чтобы получилась матрица, т.к. в матрице могут храниться данные только одного типа!
# Это в свою очередь может привести к неожиданному результату:
sapply(iris, is.numeric)
apply(iris, 2, is.numeric)
# step 3 by tapply
tapply(mtcars$mpg, mtcars$am, function(x) mean(x))
aggregate(mpg ~ am, mtcars, function(x) mean(x))
by(iris[1:4], iris$Species,
function(x) sapply(x,
function(col) shapiro.test(col)$p.value))
aggregate(. ~ Species, iris, function(x) shapiro.test(x)$p.value)
vapply(mtcars, mean, FUN.VALUE = numeric(1))
sapply(mtcars, mean)
mapply(rep, c(1, 2, 3, 4), c(1, 2, 3, 4))
rep(1, 3)
x <- c(20, 25, 13)
m <- c(0, 1, 2)
s <- c(3, 5, 6)
rnorm
mapply(rnorm, x, m, s)
m <- matrix(rnorm(100 * 200), nrow = 100)
#### Step 9 of 16  ####
# Давайте рассмотрим один небольшой пример работы с функцией mapply. Я оговорился, что она довольно специфична, однако иногда она все-таки
# оказывается довольно полезной.
# Допустим у нас есть матрица размером 100 на 200:
m <- matrix(rnorm(100 * 200), nrow = 100)
m
# И мы хотим присвоить имена строчкам и столбикам в этой матрице по принципу:
# row_1, row_2, row_3, ..., row_100 - для строк
# col_1, col_2, col_3, ..., col_200 - для колонок
# Тогда мы могли бы сгенерировать список данными именами следующим образом:
m_names <- mapply(paste, list("row", "col"), list(1:100, 1:200), sep = "_")
str(m_names) List of 2
str(m_names)
m_names
m
#### Step 10 of 16  ####
# Хотелось бы рассмотреть еще один подводный камень применения функций семейства apply к dataframe.
# Предположим, мы решили написать простенькую функцию для расчета стандартного отклонения количественных переменных в данных.
get_sd <- function(x){
num_var <- sapply(x, is.numeric)
sapply(x[, num_var], sd)
}
sapply(x, is.numeric)
# Казалось бы, все логично и работает на различных примерах:
get_sd(iris)
min_size <- numeric(nrow(diamonds)) # ?????????????? ???????????? min_size ???????? numeric ?????????? nrow(diamonds)
remove(list = ls())
data(diamonds)
data('diamonds')
str(diamonds)
#### Packages and librarys. ____________________________________________________________________________________________________ ####
library(ggplot2)
data(diamonds)
str(diamonds)
library(dplyr)
diam <- data_frame(diamonds)
diam
str(diam)
typeof(diam$cut)
min_size <- numeric(nrow(diamonds)) # ?????????????? ???????????? min_size ???????? numeric ?????????? nrow(diamonds)
min_size <- numeric(nrow(diamonds)) # ?????????????? ???????????? min_size ???????? numeric ?????????? nrow(diamonds)
for (i in 1:nrow(diamonds)) {
min_size[i] <- min(diamonds[i, 8:10])
}
min_size[2]
head(min_size)
mean_size_2 <- apply(diamonds[, 8:10], 1, min)
mean_size_2
rm(mean_size_2)
min_size_2 <- apply(diamonds[, 8:10], 1, min)
min_size == min_size_2
d <- matrix(rnorm(30), nrow = 5)
d
d
apply(d, MARGIN = 1, FUN = sd)
apply(d, MARGIN = 2, FUN = sd)
apply(mtcars, 2, sd)
apply(mtcars, 1, sd)
s <- apply(d, MARGIN = 2, FUN = sd)
s
is.vector(s) # s ?????? ????????????
range(1:10)
my_range <- apply(d, MARGIN = 2, FUN = range)
is.array(my_range) # my_range ?????? ????????????
my_range
# step 8 apply advanced
outliers_count <- function(x){
otliers <- x[abs(x - mean(x)) > 2 * sd(x)]
if (length(otliers) > 0){
return(otliers)
} else {
return("There are no otliers")
}
}
# step 8 apply advanced
outliers_count <- function(x){
otliers <- x[abs(x - mean(x)) > 2 * sd(x)]
if (length(otliers) > 0){
return(otliers)
} else {
return("There are no otliers")
}
}
iris_num <- iris[, 1:4]
iris_outliers <- apply(iris_num, 2, outliers_count)
iris_outliers
is.list(iris_outliers) # iris_outliers ?????? ????????
str(iris_outliers)
row_max <- apply(my_df, MARGIN = 1, FUN = max)
row_max
data(diamonds)
apply(airquality, 2, mean, na.rm = T)
d <- as.data.frame(matrix(rnorm(30), nrow = 5))
d <- as_data_frame(matrix(rnorm(30), nrow = 5))
d <- as_data_frame(matrix(rnorm(30), nrow = 5))
d
my_fun <- function(x) x * 2
my_fun
d[1, 1] <- NA
d
# step 3
set.seed(42)
d <- as_data_frame(matrix(rnorm(30), nrow = 5))
my_fun <- function(x) x * 2
d[1, 1] <- NA
d
for (i in seq_along(d)){ # The seq_along function creates the sequence from 1 to the namber of columns in the data frame
temp_col <- d[, i] # create temp_col variable to store the data frame column number
neg_numbers <- temp_col[temp_col < 0] # create neg_numbers variable to store negative numbers the i columns of data frame
my_list[[i]] <- neg_numbers # save the negative numbers of i columns in i elements of my_list variable
}
# let's write code, which records all negative values of each column
my_list <- list() # first of all we create a variable, which is a list. Necessary to create a list is due to the fact that different columns can
for (i in seq_along(d)){ # The seq_along function creates the sequence from 1 to the namber of columns in the data frame
temp_col <- d[, i] # create temp_col variable to store the data frame column number
neg_numbers <- temp_col[temp_col < 0] # create neg_numbers variable to store negative numbers the i columns of data frame
my_list[[i]] <- neg_numbers # save the negative numbers of i columns in i elements of my_list variable
}
my_list
names(my_list) <- colnames(d) # We can assign list names to column names
my_list
my_list <- apply(d, 2, function(x) x[x < 0])
my_list
x <- as.data.frame(matrix(rnorm(30), ncol = 6))
get_negative_values <- apply(x, 2, FUN = function(x) {
x[is.na(x)] <- 0
x[x < 0]
}
)
get_negative_values(x)
get_negative_values <- apply(x, 2, FUN = function(x) {
x[is.na(x)] <- 0
x[x < 0]
}
)
get_negative_values <- apply(x, 2, FUN = function(x) {
x[is.na(x)] <- 0
x[x < 0]
}
get_negative_values <- apply(x, 2, FUN = function(x) { x[is.na(x)] <- 0 x[x < 0] }
get_negative_values <- apply(x, 2, FUN = function(x) { x[is.na(x)] <- 0 x[x < 0] })
get_negative_values <- apply(x, 2, FUN = function(x) {
x[is.na(x)] <- 0
x[x < 0] })
get_negative_values <- apply(x, 2, function(x) {
x[is.na(x)] <- 0
x[x < 0]})
get_negative_values <- apply(x, 2, function(x) {
x[is.na(x)] <- 0
return(x[x < 0])})
# 2
apply(d, 2, FUN =
function(x) {
y <- x[x > 0]
return(y)
}
)
get_negative_values <- apply(x, 2, FUN =
function(x) {
x[is.na(x)] <- 0
x[x < 0]})
head(iris)
aov_result <- apply(iris[, 1:4], 2, function(x) aov(x ~ iris$Species))
aov_result
aov_result <- apply(iris[, 1:4], 2, function(x) aov(x ~ iris$Species))
aov_result
aov(x ~ iris$Species))
norm_test <- apply(iris[, 1:4], 2,
function(x) shapiro.test(x))
norm_test_p <- apply(iris[, 1:4], 2,
function(x) shapiro.test(x)$p.value)
norm_test_p
norm_test
norm_test_p
getwd()
setwd("C:/Users/GudievZK/Desktop/GitHub/DF/")
setwd("/Users/zelimkhan/Desktop/Data/GitHub/DF/")#
yt <- read.csv2("yt.csv")
remove(list = ls())
yt <- read.csv2("yt.csv")
View(yt)
df <- mtcars
View(df)
