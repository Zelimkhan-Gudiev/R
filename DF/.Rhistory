my_var1 <- 42
my_var2 <- 35.25
my_var1 + 100
my_var1
my_var1 + my_var2 - 12
my_var3 <- my_var1^2 + my_var2^2
my_var3 > 200
my_var3 > 30099
my_var1 == my_var2
my_var1 != my_var2
my_new_var <- my_var1 == my_var2
1 : 67
my_vector1 <- 1:67
my_vector2 <- c(-32, 45, 67, 12.78, 129, 0, -65)
my_vector1[1]
my_vector1[3]
my_vector2[2]
my_vector2[c(1,2,3)]
1:3
my_vector2[1:3]
my_vector2[c(1,5,6,7,10)]
my_vector1 + 10
my_vector2 + 56
my_vector2 == 0
my_vector1 > 30
x <- 23
my_vector1 > 23
my_vector1 > x
x == 23
my_vector2 > 0
my_vector2[my_vector2 > 0]
my_vector2[my_vector2 < 0]
my_vector2[my_vector2 == 0]
my_vector1[my_vector1 > 20 & my_vector1 < 30]
positive_numbers <- my_vector2[my_vector2 > 0]
my_vector2
positive_numbers
v1 <-  c(165, 178, 180, 181, 167, 178, 187, 167, 187)
mean_v1 <- mean(v1)
mean_v1
v1[v1 > mean_v1]
greater_than_mean <- v1[v1 > mean_v1]
greater_than_mean
age <- c(16, 18, 22, 27)
is_maried <- c(F, F, T, T)
name <- c("Olga", "Maria", "Nastya", "Polina")
data <- list(age, is_maried, name)
View(data)
data
View(data)
data[[1]][1]
View(data)
data[[2]][3]
df <- data.frame(Name = name, Age = age, Status = is_maried)
View(df)
head(df)
typeof(df)
mydata <- read.csv('evals.csv')
source("~/Desktop/Data/GitHub/1.3_my_script.R")
source("~/Desktop/Data/GitHub/1.3_my_script.R")
my_var1  <- 42 # создаем переменные
my_var2  <- 35.25 # создаем переменные
# с переменными можно работать
my_var1 + 100 # 42 + 100 = 142
my_var1 + my_var2 - 12 # 42 + 35.25 = 65.25
my_var3  <- my_var1^2 + my_var2^2 # 42^2 + 35.25^2 = 3006.562
#### Step 3: Logical operations _______________________________________________________________________________________________________________ ####
my_var3 > 200 # Правда ли, что my_var3 (3006.562) больше чем 200? Ответ: TRUE
my_var3 > 3009 # Правда ли, что my_var3 (3006.562) больше чем 200? Ответ: FALSE
my_var1 == my_var2 # Правда ли, что my_var1 (42) равна my_var2 (35.25)? Ответ: FALSE
my_var1 != my_var2 # Правда ли, что my_var1 (42) НЕ равна my_var2 (35.25)? Ответ: TRUE
my_var3 >= 200 # Правда ли, что my_var3 (3006.562) больше или равна 200? Ответ: TRUE
my_var3 <= 200 # Правда ли, что my_var3 (3006.562) меньше или равна 200? Ответ: FALSE
my_new_var  <- my_var1 == my_var2 # результат выполенения логических операций можно сохранять в переменные
#### Приммечание == ___________________________________________________________________________________________________________________________ ####
# знак ==  используется для сравнения. 1 == 2 Ответ: нет
# знак = используется для присвоения. а = 2 Результат в переменной а сохрарено число 2
#### Step 7 of 16. Задача ####
# В уже созданных переменных number_1, number_2 и number_3, сохранены целые числа.
# Проверьте, действительно ли сумма первых двух чисел строго больше, чем третье число.
# Результат сравнения (TRUE или FALSE) сохраните в новую переменную с именем result.
sum_1_2 <- number_1 + number_2 # Переменные number_1, number_2, number_3 уже созданы в невидимой для вас части кода!:)
result <- sum_1_2 > number_3
#### Step 6, 7, 10, 11: Vectors _______________________________________________________________________________________________________________ ####
1 : 67 # создаем вектор (последовательность чисел)
my_vector1  <- 1:67 # создаем переменную и сохраняем в нее вектор (последовательность чисел)
my_vector2  <- c(-32, 45, 67, 12.78, 129, 0, -65) # если хотим сами указать числа последовательности, то испольуем ф. "c" (Combine)
?c  # Combine Values into a Vector or List
#### Step 9 of 16. Обращение к элементам вектора _______________________________________________________________________________________________####
my_vector1[1] # чему равняется первый элемент вектора my_vector1
my_vector1[3] # чему равняется третий элемент вектора my_vector1
my_vector2[2] # чему равняется второй элемент вектора my_vector2
my_vector2[c(1,2,3)] # выводим 1, 2 и 3 элемент my_vector2. Чтобы обратиться к нескольким элементам нужно
# в индексе указывать вектор [c(1,2,3)]
my_vector2[1:3] # выводим 1, 2 и 3 элемент my_vector2. Чтобы обратиться к нескольким элементам нужно
# в индексе указывать вектор [1:3]
my_vector2[c(1,5,6,7,10)] # выводим 1,5,6,7,10 элемент my_vector2. 10 - NA
#### Step 10 of 16. Обращение к элементам вектора ______________________________________________________________________________________________####
# При помощи функции с() мы можем объединять не только несколько чисел, но сразу несколько векторов. Например:
vector_1 <- c(1,2,3)
vector_2 <- c(4,5,6)
vector_3 <- c(vector_1, vector_2)
# Данная операция называется конкатенацией векторов. В результате vector_3 будет содержать последовательность чисел от 1 до 6.
# Создайте переменную the_best_vector, в которой хранятся числа от 1 до 5000 и затем числа от 7000 до 10000.
# v1
vector_1 <- c(1:5000)
vector_2 <- c(7000:10000)
the_best_vector <- c(vector_1, vector_2)
# v2
the_best_vector <- c(1:5000, 7000:10000)
#### Step 11 of 16. Задача. Обращение к элементам вектора ______________________________________________________________________________________####
# В уже созданной переменной my_numbers сохранен вектор из 20 целых чисел.
# Ваша задача создать новую переменную my_numbers_2, в которой будет сохранен
# 2, 5, 7, 9, 12, 16 и 20 элемент вектора my_numbers.
my_numbers_2 <- my_numbers[c(2, 5, 7, 9, 12, 16 и 20)]
#### Step 12 of 16. Обращение к элементам с помощью логических операций ________________________________________________________________________####
my_vector1 + 10 # с векторами можно выполнять арифметические операции.
my_vector2 + 56 # арифметическая операция выполняется с каждым элементом вектора. Получаем новый вектор (в консоле),
# элементы которого это результат выполления арифметической операции над каждым элементом исходного вектора
my_vector2 == 0 # с векторами можно выполнять логичекие операции
my_vector1 > 30 # логичекая операция выполняется с каждым элементом вектора. Получаем новый вектор (в консоле),
# элементы которого это результат выполления логической операции над каждым элементом исходного вектора
# Можно полностью уйти от числ и использовать вместо них переменные
x  <- 23
my_vector1 > x # сравниваеи 23 с my_vector1 <- vector_1 <- c(1:5000). Получаем новый логический вектор
x == 23 # сравниваеи x == 23. Ответ TRUE.
# Таким образом, при выполнении опреций с векторами, такие операции выполняются в отношении каждого
# элемента вектора и на выход получаем новый вектор. Понимание данного принципа важно для понимания
# процесса обращения к элементам вектора. Мы можем обращаться к элементам, которые отвечают определенным
# условиям (соответствуют вектору указанному в индексе)
my_vector2
my_vector2[my_vector2 > 0] # новый вектор используем для индексации, т.е. используем один вектор для
# обращания к элементам другого вектора
my_vector2[my_vector2 < 0] # берем вектор из отрицательных элементов my_vector2 и обращаемся с помощь него к my_vector2.
# Результат получаем новый вектор, который состоит из отрицательных элементов my_vector2
my_vector2[my_vector2 == 0]
# Результат получаем новый вектор, который состоит из отрицательных элементов my_vector2
my_vector2[my_vector2 == 1]
my_vector1
# к элеменам вектора можно обращаться с использованием сложных условий
my_vector1[my_vector1 > 20 & my_vector1 < 30]
my_numbers  <- my_vector1[my_vector1 > 20 & my_vector1 < 30]
my_numbers
positive_numbers  <- my_vector2[my_vector2 > 0]
positive_numbers
# пример
v1  <- c(165, 178, 180, 181, 167, 178, 187, 167, 187) # сохраним данные в перемменную v1
mean_v1  <- mean(v1) # сохраним в переменную mean_v1 ср. ариф всех значений перемменной v1
mean_v1
v1
v1[v1 > mean_v1]
greater_than_mean  <- v1[v1 > mean_v1] #  новый логический вектор, сохранен в новую переменную greater_than_mean
greater_than_mean
greater_than_10 <- my_vector[my_vector > 10]
greater_than_10 <- my_vector[my_vector > 10]
my_vector <- seq(1:200, by = 10)
my_vector <- seq(1, 200, by = 10)
my_vector
my_vector <- seq(1, 200, by = 9)
my_vector
my_vector <- seq(0, 200, by = 10)
my_vector
greater_than_10 <- my_vector[my_vector > 10]
greater_than_10
my_sum <- sum(greater_than_10)
my_sum
is_maried  <- c(F, F, T, T)
is_maried
name  <- c("Olga", "Maria", "Nastya", "Polina")
age  <- c(16, 18, 22, 27)
name
age  <- c(16, 18, 22, 27)
my_data  <- data.frame(Name = name, Age = age, Status = is_maried)
my_data
typeof(my_data) # list, т.к. данный дф содержит данные разного типа
my_vector <- seq(1, 20, by = 1)
greater_than_10 <- my_vector[my_vector > 10]
my_sum <- sum(greater_than_10)
my_sum
my_data <- read.csv('https://stepik.org/media/attachments/lesson/11481/evals.csv')
yt <- read.csv2("yt.csv")
head(my_data) # комманда head по умолчанию выводит шесть первых строк
head(my_data, 7) # через запятую можно указать сколько строк выводить
tail(my_data) # комманда tail по умолчанию выводит шесть последних строк
tail(my_data, 7) # через запятую можно указать сколько строк выводить
View(my_data) # функция View позволяет увидеть 1000 наблюдений (строк)
str(my_data) # показывает внутреннюю структуру объекта R
summary(my_data) # показывает некоторые сводные данные (описательные статистики для кол. переменных) дата фрейма
names(my_data)
#### ####
my_df <- read.csv("train.csv", sep=";")
yt <- read.csv2('yt.csv') # Отступление
setwd("/Users/zelimkhan/Desktop/Data/GitHub/DF/")
yt <- read.csv2('yt.csv') # Отступление
my_df <- read.csv("train.csv", sep=";")
View(my_df)
library(ggplot2)
library(psych)
library(dplyr)
library(readxl)
library(ROCR)
str(my_df)
sapply(c(my_df$gender, my_df$hon), as.factor)
str(my_df)
select_if(df, character) <-  sapply(c(my_df$gender, my_df$hon), as.factor)
select_if(my_df, character)
select_if(my_df, is.character)
select_if(my_df, is.character) <-  sapply(c(my_df$gender, my_df$hon), as.factor)
select_if(my_df, is.character) %>%  sapply(c(my_df$gender, my_df$hon), as.factor)
str(my_df) %>% select_if(my_df, is.character) %>%  sapply(c(my_df$gender, my_df$hon), as.factor)
str(my_df) %>% select_if(my_df, is.character) %>%  sapply(c(my_df$gender, my_df$hon), as.factor)
str(my_df)
my_df[, c(1, 5)] <-  sapply(c(my_df$gender, my_df$hon), as.factor)
str(my_df)
my_df <- read.csv("train.csv", sep=";")
my_df[, c(1, 5)]
my_df[, c(1, 5)] <-  sapply(c(my_df$gender, my_df$hon), as.factor)
my_df
str(my_df)
my_df[, c(1, 5)] <-  sapply(c(my_df$gender, my_df$hon), factor)
str(my_df)
my_df[, c(1, 5)] <-  lapply(my_df[, c(1, 5)], factor)
str(my_df)
select_if(my_df, character)
select_if(my_df, is.character) <-  sapply(c(my_df$gender, my_df$hon), as.factor)
select_if(my_df, is.character)
ggplot(my_df, aes(read, math, col = gender)) +
geom_point(size = 5) +
facet_grid(.~hon) +
theme(axis.text=element_text(size=25),
axis.title=element_text(size=25,face="bold"))
ggplot(my_df, aes(read, math, col = gender)) +
geom_point(size = 5) +
facet_grid(.~hon) +
theme(axis.text=element_text(size=5),
axis.title=element_text(size=25,face="bold"))
ggplot(my_df, aes(read, math, col = gender)) +
geom_point(size = 5) +
facet_grid(.~hon) +
theme(axis.text=element_text(size=25),
axis.title=element_text(size=25,face="bold"))
ggplot(my_df, aes(read, math, col = gender)) +
geom_point(size = 5) +
facet_grid(.~hon) +
theme(axis.text=element_text(size=2),
axis.title=element_text(size=25,face="bold"))
ggplot(my_df, aes(read, math, col = gender)) +
geom_point(size = 5) +
facet_grid(.~hon) +
theme(axis.text=element_text(size=25),
axis.title=element_text(size=25,face="bold"))
ggplot(my_df, aes(read, math, col = gender)) +
geom_point(size = 5) +
facet_grid(.~hon) +
theme(axis.text=element_text(size=25),
axis.title=element_text(size=2,face="bold"))
ggplot(my_df, aes(read, math, col = gender)) +
geom_point(size = 5) +
facet_grid(.~hon) +
theme(axis.text=element_text(size=25),
axis.title=element_text(size=25,face="bold"))
ggplot(my_df, aes(read, math, col = gender)) +
geom_point(size = 5) +
facet_grid(.~hon) +
theme(axis.text=element_text(size=25),
axis.title=element_text(size=2,face="bold"))
ggplot(my_df, aes(read, math, col = gender)) +
geom_point(size = 5) +
facet_grid(.~hon) +
theme(axis.text=element_text(size=25),
axis.title=element_text(size=2,face="bold"))
ggplot(my_df, aes(read, math, col = gender)) +
geom_point(size = 5) +
facet_grid(.~hon) +
theme(axis.text=element_text(size=25),
axis.title=element_text(size=1,face="bold"))
ggplot(my_df, aes(read, math, col = gender)) +
geom_point(size = 5) +
facet_grid(.~hon) +
theme(axis.text=element_text(size=25),
axis.title=element_text(size=225,face="bold"))
ggplot(my_df, aes(read, math, col = gender)) +
geom_point(size = 5) +
facet_grid(.~hon) +
theme(axis.text=element_text(size=25),
axis.title=element_text(size=25,face="bold"))
fit  <- glm(hon ~ read + math + gender, my_df, family = "binomial")
summary(fit)
exp(fit$coefficients)
head(predict(object = fit))
fit  <- glm(hon ~ read + math + gender, my_df, family = "binomial")
summary(fit)
exp(fit$coefficients)
head(predict(object = fit))
head(predict(object = fit, type = "response"))
my_df$prob  <- predict(object = fit, type = "response")
View(my_df)
head(predict(object = fit))
head(predict(object = fit))
glm(am ~ disp + vs + mpg, mtcars, family = 'binominal')
glm(am ~ disp + vs + mpg, mtcars, family = 'binomial')
glm(am ~ disp + vs + mpg, mtcars, family = 'binomial')$Coefficients
glm(am ~ disp + vs + mpg, mtcars, family = 'binomial')$coefficients
log_coef <- glm(am ~ disp + vs + mpg, mtcars, family = 'binomial')$coefficients
log_coef
obj <- ggplot(data = ToothGrowth, aes(x = supp, y = len, col = dose)) +
geom_boxplot()
obj
obj <- ggplot(data = ToothGrowth, aes(x = supp, y = len, col = as.factor(dose)) +
obj
obj <- ggplot(data = ToothGrowth, aes(x = supp, y = len, col = as.factor(dose)) +
obj
obj <- ggplot(data = ToothGrowth, aes(x = supp, y = len, col = as.factor(dose))) +
geom_boxplot()
obj
ggplot(data = ToothGrowth, aes(x = supp, y = len, col = factor(dose))) +
geom_boxplot()
ggplot(data = ToothGrowth, aes(x = supp, y = len, fill = factor(dose))) +
geom_boxplot()
obj <- ggplot(data = ToothGrowth, aes(x = supp, y = len, fill = factor(dose))) +
geom_boxplot()
obj
df <- ToothGrowth #записали в переменную датасет
class(df$dose) # увидели, чтр переменная dose имеет тип numeric , а не фактор . А нам надо фактор , чтобы закрасить ящики цветом
df$dose <- as.factor(df$dose) # перевели переменную dose в тип фактор
ggplot(df, aes(supp, len, fill = dose)) + # по оси х -supp , по оси у - len , цвет в зависимости от фактора dose
geom_boxplot() + #указали что нужны ящики с усами
theme(axis.text=element_text(size=25),
axis.title=element_text(size=25,face="bold"))
pred_fit <- prediction(my_df$prob, my_df$hon)
perf_fit <- performance(pred_fit,"tpr","fpr")
pred_fit
perf_fit
df <- read.csv(https://stepic.org/media/attachments/lesson/11478/data.csv)
df <- read.csv('https://stepic.org/media/attachments/lesson/11478/data.csv')
View(df)
df[, c(1, length(df))]
df[, c(1, length(df))] <- as.factor(df[, c(1, length(df))])
df[, c(1, length(df))] <- lapply(df[, c(1, length(df))])
df[, c(1, length(df))] <- lapply(df[, c(1, length(df))], factor)
str(df)
head(df)
fit <- glm(admit ~ rank * gpa, df, family = 'binomial')
fit
predict(fit)
predict(object = fit, type = "response")
df$prob <- predict(object = fit, type = "response")
df$prob <- predict(object = fit, type = "response")
View(df)
df <- read.csv('https://stepic.org/media/attachments/lesson/11478/data.csv')
View(df)
df[, c(1, length(df))] <- lapply(df[, c(1, length(df))], factor)
View(df)
fit <- glm(admit ~ rank * gpa, df, family = 'binomial')
df$prob <- predict(object = fit, type = "response")
fit <- glm(admit ~ rank * gpa, subset(df, admit!=NA), family = 'binomial')
fit
subset(df, admit!=NA)
subset(df, admit != 'NA')
fit <- glm(admit ~ rank * gpa, subset(df, admit != 'NA'), family = 'binomial')
df$prob <- predict(object = fit, type = "response")
df$prob <- predict(object = fit, newdata=df[is.na(df$admit),], type = "response")
predict(object = fit, newdata=df[is.na(df$admit),], type = "response")
df$prob <- predict(object = fit, newdata=df[is.na(df$admit),], type = "response")
df$prob
predict(object = fit, newdata=df[is.na(df$admit),], type = "response")
which(df, is.na(df$admit))
indxes_na <- which(df, df$admit == "NA")                                        #  1) ищем индексы строк с NA
which(df, df$admit == "NA")
indxes_na <- which(df, df$admit == NA)                                        #  1) ищем индексы строк с NA
is.na(df$admit)
which(df, is.na(df$admit))
which(df$admit, is.na(df$admit))
which(is.na(df$admit))
indxes_na <- which(is.na(df$admit))                                        #  1) ищем индексы строк с NA
indxes_na
View(df)
d_rm_na <- df[-indxes_na, ]
d_na <- df[indxes_na, ]                                             #  3) берем данные с NA
fit <- glm(admit ~ rank * gpa, d_rm_na, family = 'binomial')                                      #  4) формируем модель по данным без NA
fit
predict(object = fit, newdata=df[is.na(df$admit),], type = "response")
d_na$p.value <- predict(object = fit, type = 'response')                    # 5) записываем предсказания для данных с NA в новый столбец p.value
d_na$p.value <- predict(object = fit, newdata = d_na, type = 'response')        # 5) записываем предсказания для данных с NA в новый столбец p.value
d_na$p.value <- predict(object = fit, newdata = d_na, type = 'response')        # 5) записываем предсказания для данных с NA в новый столбец p.value
d_na$p.value
df$p.value <- predict(object = fit, newdata = d_na, type = 'response')        # 5) записываем предсказания для данных с NA в новый столбец p.value
nrow(d_na[d_na$p.value >= 0.4,])                                                # 6) считаем строки с предсказанием о поступлении для данных с NA
