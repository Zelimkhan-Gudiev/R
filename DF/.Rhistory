# медианным значением. Сделайте выводы.
winsor.mean(select_if(myData, is.numeric), trim = 0.2, na.rm = TRUE)
modMed <- summary(myData)
rm(modMed)
modMed <- summary(myData)
modMed
modMed[c(median, means), -5]
modMed[c(median, mean), -5]
modMed[c(modMed$median, modMed$mean), -5]
modMed <- summary(myData)
modMed
rm(modMed)
aggregate(myDataNA, FUN = c(mean, median()))
mean(select_if(myData, is.numeric))
mean(select_if(myData, is.numeric)
means(select_if(myData, is.numeric)
means(select_if(myData, is.numeric))
mean(select_if(myData, is.numeric))
winsor.mean(select_if(myDataNA, is.numeric), trim = 0.2, na.rm = TRUE)
mean(select_if(myData, is.numeric))
mean(select_if(myData, is.numeric))
mean(myData$Sepal.Length)
mean(c(myData$Sepal.Length, myData$Sepal.Width, myData$Petal.Length, myData$Petal.Width)
mean(c(myData$Sepal.Length, myData$Sepal.Width, myData$Petal.Length, myData$Petal.Width))
mean(myData$Sepal.Length, myData$Sepal.Width, myData$Petal.Length, myData$Petal.Width)
myData
names(myData)
aggregate(cbind(Sepal.Length, Sepal.Width),  myData, sd)
aggregate(cbind('Sepal.Length', 'Sepal.Width'),  myData, sd)
aggregate(cbind('Sepal.Length', 'Sepal.Width'),  myData, mean)
describe(myData)
describe
describe(myDataNA)
describe(myDataNA)[-5, 3]
winsor.mean(select_if(myDataNA, is.numeric), trim = 0.2, na.rm = TRUE)
names(myData)
winsor.mean(select_if(myDataNA, is.numeric), trim = 0.2, na.rm = TRUE)
describe(myDataNA)
describe(myDataNA[, -5])
describe(myDataNA[, -5])['mean']
describe(myDataNA[, -5])['mean', 'sd']
describe(myDataNA[, -5])['mean', 'median']
describe(myDataNA[, -5])[c('mean', 'median')]
describe(myDataNA[, -5])[c('mean', 'median')]
winsor.mean(select_if(myDataNA, is.numeric), trim = 0.2, na.rm = TRUE)
as.data.frame(winsor.mean(select_if(myDataNA, is.numeric), trim = 0.2, na.rm = TRUE))
as.data.frame(winsor.mean(select_if(myData, is.numeric), trim = 0.2, na.rm = TRUE))
describe(myDataNA[, -5])[c('mean', 'median')]
# Проверьте данные на наличие выбросов по каждой переменной, присвоив ей буквенное значение (x1, х2, х3…).
x1 <- myData[, 1]
boxplot.stats(x1)$out
boxplot(x1)
# Значения, которые являются выбросами для всех переменных:
df <- data.frame(x1, х2, х3, х4)
x2 <- myData[, 2]
boxplot.stats(x2)$out
boxplot(x2)
x3 <- myData[, 3]
boxplot.stats(x3)$out
boxplot(x3)
x4 <- myData[, 4]
boxplot.stats(x4)$out
boxplot(x4)
boxplot(x3)
x4 <- myData[, 4]
boxplot.stats(x4)$out
boxplot(x4)
boxplot.stats(x3)$out
boxplot.stats(x4)$out
boxplot.stats(x2)$out
df <- data.frame(x1, х2, х3, х4)
x2 <- myData[, 2]
boxplot.stats(x2)$out
boxplot(x2)
# Значения, которые являются выбросами для всех переменных:
df <- data.frame(x1, х2, х3, х4)
# Значения, которые являются выбросами для всех переменных:
df <- data.frame(x1, x2, х3, х4)
# Значения, которые являются выбросами для всех переменных:
df <- data.frame(x1, x2, x3, x4)
df
rm(x1,х2,х3,х4)
attach(df)
(a <- which(x1 %in% boxplot.stats(x1)$out))
rm(x1,х2,х3,х4)
attach(df)
a <- which(x1 %in% boxplot.stats(x1)$out)
a <- which(x1 %in% boxplot.stats(x1)$out)
a
(a <- which(SEPALLEN%in% boxplot.stats(SEPALLEN)$out))
a <- which(SEPALLEN%in% boxplot.stats(SEPALLEN)$out)
df
df <- data.frame(x1, x2, x3, x4)
a <- which(x1 %in% boxplot.stats(x1)$out)
a
b <- which(х2 %in% boxplot.stats(х2)$out)
(b <- which(х2 %in% boxplot.stats(х2)$out))
(c<- ……….
(a <- which(x1 %in% boxplot.stats(x1)$out))
(b <- which(х2 %in% boxplot.stats(x2)$out))
(a <- which(x1 %in% boxplot.stats(x1)$out))
(b <- which(x2 %in% boxplot.stats(x2)$out))
boxplot.stats(x4)$out
boxplot.stats(x2)$out
(c<-  which(x3 %in% boxplot.stats(x3)$out))
(c <-  which(x3 %in% boxplot.stats(x3)$out))
(d <-  which(x4 %in% boxplot.stats(x4)$out))
d <-  which(x4 %in% boxplot.stats(x4)$out)
(d <-  which(x4 %in% boxplot.stats(x4)$out))
detach(df)
df
outlier.list1 <- intersect(х1,х2,х3,х4))
df
outlier.list1 <- intersect(х1,х2,х3,х4))
oulier_list1 <- Reduce(intersect, list(a,b,c,d))
oulier_list2 <- Reduce(union, list(a,b,c,d))
oulier_list1
oulier_list2
# Для выделения выбросов необходимо убрать, при ее наличии, качественную переменную, записав данные под новым именем:
myData2 <- myData[,1:4]
head(myData2)
kmeans.result <- kmeans(myData2, centers = 3)
# Проведите кластеризацию методом К-средних, выделив три кластера:
kmeans.result <- kmeans(myData2, centers = 3, na.rm = T)
# Проведите кластеризацию методом К-средних, выделив три кластера:
kmeans.result <- kmeans(myData2, centers = 3)
head(df)
View(myDataNA)
# Проведите кластеризацию методом К-средних, выделив три кластера:
kmeans.result <- kmeans(df, centers = 3)
df <- data.frame(x1, x2, x3, x4)
kmeans.result <- kmeans(df, centers = 3)
# Проведите кластеризацию методом К-средних, выделив три кластера:
is.na(df)
# Проведите кластеризацию методом К-средних, выделив три кластера:
sum(is.na(df))
# Проведите кластеризацию методом К-средних, выделив три кластера:
sum(is.na(myData))
myData[] <- lapply(myData_NA, na.aggregate)
sum(is.na(myData)) # 0 NA
myData[] <- lapply(myData_NA, na.aggregate)
myData[] <- lapply(myDataNA, na.aggregate)
sum(is.na(myData)) # 0 NA
x1 <- myData[, 1]
boxplot.stats(x1)$out
boxplot(x1)
x2 <- myData[, 2]
boxplot.stats(x2)$out
boxplot(x2)
x3 <- myData[, 3]
boxplot.stats(x3)$out
boxplot(x3)
x4 <- myData[, 4]
boxplot.stats(x4)$out
boxplot(x4)
# Значения, которые являются выбросами для всех переменных:
df <- data.frame(x1, x2, x3, x4)
rm(x1,х2,х3,х4)
rm(x1, x2, x3, x4)
# Проведите кластеризацию методом К-средних, выделив три кластера:
sum(is.na(myData))
kmeans.result <- kmeans(df, centers = 3)
kmeans.result
# Отобразите центры кластеров:
kmeans.result$centers
# Рассчитайте расстояния от объектов до центров кластеров:
centers <- kmeans.result$centers[kmeans.result$cluster, ]
distances <- sqrt(rowSums((myData2 - centers)^2))
centers
distances
distances <- sqrt(rowSums((myData - centers)^2))
distances
# Рассчитайте расстояния от объектов до центров кластеров:
centers <- kmeans.result$centers[kmeans.result$cluster, ]
distances <- sqrt(rowSums((myData - centers)^2))
myData <- myData[, 1:4]
# Проведите кластеризацию методом К-средних, выделив три кластера:
sum(is.na(myData))
kmeans.result <- kmeans(df, centers = 3)
kmeans.result
# Рассчитайте расстояния от объектов до центров кластеров:
centers <- kmeans.result$centers[kmeans.result$cluster, ]
centers
distances <- sqrt(rowSums((myData - centers)^2))
distances
# Возьмите несколько (например, 5) наибольших получившихся расстояний.
outliers <- order(distances, decreasing=T)[1:5]
outliers
print(outliers)
print(myData[outliers, ])
plot(iris2[,c("Sepal.Length", "Sepal.Width")], pch="o", col=kmeans.result$cluster, cex=0.3)
points(kmeans.result$centers[,c("Sepal.Length", "Sepal.Width")], col=1:3, pch=8, cex=1.5)
points(iris2[outliers, c("Sepal.Length", "Sepal.Width")], pch="+", col=4, cex=1.5)
plot(iris2[,c("Sepal.Length", "Sepal.Width")], pch="o", col=kmeans.result$cluster, cex=0.3)
plot(myData[,c("Sepal.Length", "Sepal.Width")], pch="o", col=kmeans.result$cluster, cex=0.3)
plot(myData[, c("Sepal.Length", "Sepal.Width")], pch ="o", col = kmeans.result$cluster, cex = 0.3)
points(kmeans.result$centers[, c("Sepal.Length", "Sepal.Width")], col = 1:3, pch = 8, cex = 1.5)
points(myData[outliers, c("Sepal.Length", "Sepal.Width")], pch = "+", col = 4, cex = 1.5)
points(kmeans.result$centers[, c("Sepal.Length", "Sepal.Width")], col = 1:3, pch = 8, cex = 1.5)
points(kmeans.result$centers[, c("Sepal.Length", "Sepal.Width")], col = 1:3, pch = 8, cex = 1.5)
plot(myData[, c("Sepal.Length", "Sepal.Width")], pch ="o", col = kmeans.result$cluster, cex = 0.3)
points(kmeans.result$centers[, c("Sepal.Length", "Sepal.Width")], col = 1:3, pch = 8, cex = 1.5)
points(myData[outliers, c("Sepal.Length", "Sepal.Width")], pch = "+", col = 4, cex = 1.5)
plot(myData[, c("Sepal.Length", "Sepal.Width")], pch ="o", col = kmeans.result$cluster, cex = 0.3)
print(myData[outliers, ])
print(myData[outliers, ])
plot(myData[, c("Sepal.Length", "Sepal.Width")], pch ="o", col = kmeans.result$cluster, cex = 0.3)
points(kmeans.result$centers[, c("Sepal.Length", "Sepal.Width")], col = 1:3, pch = 8, cex = 1.5)
points(kmeans.result$centers[, c("Sepal.Length", "Sepal.Width")], col = 1:3, pch = 8, cex = 1.5)
kmeans.result$centers
points(kmeans.result$centers[, c("Sepal.Length", "Sepal.Width")], col = 1:3, pch = '8', cex = 1.5)
points(kmeans.result$centers[, c("Sepal.Length", "Sepal.Width")], col = 1:3, pch = "8", cex = 1.5)
kmeans.result$centers[, c("Sepal.Length", "Sepal.Width")]
plot(myData[, c("Sepal.Length", "Sepal.Width")], pch ="o", col = kmeans.result$cluster, cex = 0.3)
points(kmeans.result$centers[, c("x1", "x2")], col = 1:3, pch = 8, cex = 1.5)
points(myData[outliers, c("Sepal.Length", "Sepal.Width")], pch = "+", col = 4, cex = 1.5)
print(myData[outliers, ])
# Кратко опишите, какие наблюдения являются аномальными:
# Ответ:
names(myData[outliers, ])
# Кратко опишите, какие наблюдения являются аномальными:
# Ответ:
rownames(myData[outliers, ])
oulier_list1
oulier_list2
# Кратко опишите, какие наблюдения являются аномальными:
# Ответ:
rownames(myData[outliers, ]) # "99",  "58", "94", "61", "119"
oulier_list1 <- Reduce(intersect, list(a,b,c,d))
oulier_list1
oulier_list2
oulier_list2
outliers <- order(distances, decreasing=T)[1:5]
outliers
sqrt(rowSums((myData - centers)^2))
setwd("C:/Users/GudievZK/Desktop/GitHub/DF/)
myData <- read.csv("C:/Users/GudievZK/Desktop/GitHub/DF/tourism.csv")
### Задание 1. ###
# Имеется фрагмент базы данных об анкетировании клиентов турфирмы. Разделите данные на обучающую и тестовую выборки по 70% и 30%,
# либо используя другие проценты по своему усмотрению.
# library(party)
set.seed(1234)
ind <- sample(2, nrow(myData), replace=TRUE, prob=c(0.7, 0.3))
trainData <- myData[ind == 1,]
testData<- myData[ind == 2,]
# Постройте дерево решений на основе пакета party, выбрав интересующую Вас зависимую переменную. Поясните Ваш выбор.
# В частности, какую неизвестную информацию об исходных данных позволит получить построение дерева решений для этой переменной?
# Обозначьте зависимую переменную как Y, и классификационные переменные как Х1, Х2, и т.д., либо другим удобным способом.
# library(party)
myFormula <- Y ~ X1 + X2 + X3 + ... + Xk
myData_ctree <- ctree(myFormula, data=trainData)
# Приведите матрицу классификации.
> table(predict(myData_ctree),
trainData$имя_выбранной_результативной_переменной)
Приведите результаты построения дерева решений в виде таблицы.
> print(myData_ctree)
Опишите последовательность проведения классификации с точки зрения переменных.
Приведите дерево решений на графике в общем виде.
> plot(myData_ctree)
Приведите дерево решений на графике в упрощенном виде.
> plot(myData_ctree, type="simple")
Дайте интерпретацию дерева решений с точки зрения листьев (терминальных узлов).
Опишите вероятности для каждого класса результативного признака, указав количество
наблюдений в каждом классе, с точки зрения значений параметров классифицирующих
признаков.
Сведите полученные выводы в небольшую аналитическую записку о результатах
классификации.
Примените полученное дерево решений для тестовых данных. Дайте общую характеристику
ошибкам классификации.
> testPred<-predict(myData_ctree, newdata=testData)
> table(testPred, testData$имя_выбранной_результативной_переменной)
setwd("C:/Users/GudievZK/Desktop/GitHub/DF/)
myData <- read.csv("C:/Users/GudievZK/Desktop/GitHub/DF/tourism.csv")
### Задание 1. ###
# Имеется фрагмент базы данных об анкетировании клиентов турфирмы. Разделите данные на обучающую и тестовую выборки по 70% и 30%,
# либо используя другие проценты по своему усмотрению.
# library(party)
set.seed(1234)
ind <- sample(2, nrow(myData), replace=TRUE, prob=c(0.7, 0.3))
trainData <- myData[ind == 1,]
testData<- myData[ind == 2,]
# Постройте дерево решений на основе пакета party, выбрав интересующую Вас зависимую переменную. Поясните Ваш выбор.
# В частности, какую неизвестную информацию об исходных данных позволит получить построение дерева решений для этой переменной?
# Обозначьте зависимую переменную как Y, и классификационные переменные как Х1, Х2, и т.д., либо другим удобным способом.
# library(party)
myFormula <- Y ~ X1 + X2 + X3 + ... + Xk
myData_ctree <- ctree(myFormula, data=trainData)
# Приведите матрицу классификации.
> table(predict(myData_ctree),
trainData$имя_выбранной_результативной_переменной)
Приведите результаты построения дерева решений в виде таблицы.
> print(myData_ctree)
Опишите последовательность проведения классификации с точки зрения переменных.
Приведите дерево решений на графике в общем виде.
> plot(myData_ctree)
Приведите дерево решений на графике в упрощенном виде.
> plot(myData_ctree, type="simple")
Дайте интерпретацию дерева решений с точки зрения листьев (терминальных узлов).
Опишите вероятности для каждого класса результативного признака, указав количество
наблюдений в каждом классе, с точки зрения значений параметров классифицирующих
признаков.
Сведите полученные выводы в небольшую аналитическую записку о результатах
классификации.
Примените полученное дерево решений для тестовых данных. Дайте общую характеристику
ошибкам классификации.
> testPred<-predict(myData_ctree, newdata=testData)
> table(testPred, testData$имя_выбранной_результативной_переменной)
remove(list = ls())
getwd()
setwd("C:/Users/GudievZK/Desktop/GitHub/DF/)
setwd("C:/Users/GudievZK/Desktop/GitHub/DF/)
myData <- read.csv("C:/Users/GudievZK/Desktop/GitHub/DF/tourism.csv")
### Задание 1. ###
# Имеется фрагмент базы данных об анкетировании клиентов турфирмы. Разделите данные на обучающую и тестовую выборки по 70% и 30%,
# либо используя другие проценты по своему усмотрению.
# library(party)
set.seed(1234)
ind <- sample(2, nrow(myData), replace=TRUE, prob=c(0.7, 0.3))
trainData <- myData[ind == 1,]
testData<- myData[ind == 2,]
# Постройте дерево решений на основе пакета party, выбрав интересующую Вас зависимую переменную. Поясните Ваш выбор.
# В частности, какую неизвестную информацию об исходных данных позволит получить построение дерева решений для этой переменной?
# Обозначьте зависимую переменную как Y, и классификационные переменные как Х1, Х2, и т.д., либо другим удобным способом.
# library(party)
myFormula <- Y ~ X1 + X2 + X3 + ... + Xk
myData_ctree <- ctree(myFormula, data=trainData)
# Приведите матрицу классификации.
> table(predict(myData_ctree),
trainData$имя_выбранной_результативной_переменной)
Приведите результаты построения дерева решений в виде таблицы.
> print(myData_ctree)
Опишите последовательность проведения классификации с точки зрения переменных.
Приведите дерево решений на графике в общем виде.
> plot(myData_ctree)
myData
ind <- sample(2, nrow(myData), replace=TRUE, prob=c(0.7, 0.3))
myData <- read.csv("C:/Users/GudievZK/Desktop/GitHub/DF/tourism.csv")
remove(list = ls())
library(party)
library(rpart)
library(randomForest)
myData <- read.csv("C:/Users/GudievZK/Desktop/GitHub/DF/tourism.csv")
remove(list = ls())
myData <- read.csv("C:/Users/GudievZK/Desktop/GitHub/DF/tourism.csv")
## Считаем данные ###
getwd()
set.seed(1234)
ind <- sample(2, nrow(myData), replace=TRUE, prob=c(0.7, 0.3))
ind
View(myData)
tourism
trainData <- myData[ind == 1, ]
testData<- myData[ind == 2, ]
# Постройте дерево решений на основе пакета party, выбрав интересующую Вас зависимую переменную. Поясните Ваш выбор.
# В частности, какую неизвестную информацию об исходных данных позволит получить построение дерева решений для этой переменной?
# Обозначьте зависимую переменную как Y, и классификационные переменные как Х1, Х2, и т.д., либо другим удобным способом.
# library(party)
myFormula <- Y ~ X1 + X2 + X3 + ... + Xk
View(myData)
myData_ctree <- ctree(myFormula, data=trainData)
# Постройте дерево решений на основе пакета party, выбрав интересующую Вас зависимую переменную. Поясните Ваш выбор.
# В частности, какую неизвестную информацию об исходных данных позволит получить построение дерева решений для этой переменной?
# Обозначьте зависимую переменную как Y, и классификационные переменные как Х1, Х2, и т.д., либо другим удобным способом.
# library(party)
str(myData)
# Постройте дерево решений на основе пакета party, выбрав интересующую Вас зависимую переменную. Поясните Ваш выбор.
# В частности, какую неизвестную информацию об исходных данных позволит получить построение дерева решений для этой переменной?
# Обозначьте зависимую переменную как Y, и классификационные переменные как Х1, Х2, и т.д., либо другим удобным способом.
# library(party)
library(dplyr)
str(myData)
select_if(myData, is.character)
names(select_if(myData, is.character))
factorNames <- names(select_if(myData, is.character))
sapply(myData, factorNames, as.factor)
lapply(myData[factorNames], as.factor)
# Постройте дерево решений на основе пакета party, выбрав интересующую Вас зависимую переменную. Поясните Ваш выбор.
# В частности, какую неизвестную информацию об исходных данных позволит получить построение дерева решений для этой переменной?
# Обозначьте зависимую переменную как Y, и классификационные переменные как Х1, Х2, и т.д., либо другим удобным способом.
# library(party)
str(myData)
lapply(myData[factorNames], as.factor)
lapply(myData[factorNames], factor)
myData <- lapply(myData[factorNames], factor)
# Постройте дерево решений на основе пакета party, выбрав интересующую Вас зависимую переменную. Поясните Ваш выбор.
# В частности, какую неизвестную информацию об исходных данных позволит получить построение дерева решений для этой переменной?
# Обозначьте зависимую переменную как Y, и классификационные переменные как Х1, Х2, и т.д., либо другим удобным способом.
# library(party)
str(myData)
View(myData)
myData <- read.csv("C:/Users/GudievZK/Desktop/GitHub/DF/tourism.csv")
set.seed(1234)
ind <- sample(2, nrow(myData), replace = TRUE, prob = c(0.7, 0.3)) #
trainData <- myData[ind == 1, ]
testData<- myData[ind == 2, ]
# Постройте дерево решений на основе пакета party, выбрав интересующую Вас зависимую переменную. Поясните Ваш выбор.
# В частности, какую неизвестную информацию об исходных данных позволит получить построение дерева решений для этой переменной?
# Обозначьте зависимую переменную как Y, и классификационные переменные как Х1, Х2, и т.д., либо другим удобным способом.
# library(party)
str(myData)
factorNames <- names(select_if(myData, is.character))
myData[, factorNames] <- lapply(myData[factorNames], factor)
# Постройте дерево решений на основе пакета party, выбрав интересующую Вас зависимую переменную. Поясните Ваш выбор.
# В частности, какую неизвестную информацию об исходных данных позволит получить построение дерева решений для этой переменной?
# Обозначьте зависимую переменную как Y, и классификационные переменные как Х1, Х2, и т.д., либо другим удобным способом.
# library(party)
str(myData)
myFormula <- myData$AGE ~ myData$COMPANIONS + myData$CHOICE + myData$LENGTH + myData$TIMES_YEAR +
+ myData$AIM + myData$EXPENCES + myData$ORGANIZE +
+ myData$TYPE + myData$HOTEL_QUAL
myFormula
myFormula <- myData
View(myFormula)
myData_ctree <- ctree(myFormula, data=trainData)
myData_ctree <- ctree(myFormula, data = Data)
myFormula <- trainData$AGE ~ trainData$COMPANIONS + trainData$CHOICE + trainData$LENGTH + trainData$TIMES_YEAR +
+ trainData$AIM + trainData$EXPENCES + trainData$ORGANIZE +
+ trainData$TYPE + trainData$HOTEL_QUAL
myFormula <- myData
View(myFormula)
myData_ctree <- ctree(myFormula, data = trainData)
# Постройте дерево решений на основе пакета party, выбрав интересующую Вас зависимую переменную. Поясните Ваш выбор.
# В частности, какую неизвестную информацию об исходных данных позволит получить построение дерева решений для этой переменной?
# Обозначьте зависимую переменную как Y, и классификационные переменные как Х1, Х2, и т.д., либо другим удобным способом.
# library(party)
str(myData)
trainData
View(testData)
View(trainData)
View(testData)
View(trainData)
myFormula <- trainData$AGE ~ trainData$COMPANIONS + trainData$CHOICE + trainData$LENGTH + trainData$TIMES_YEAR +
+ trainData$AIM + trainData$EXPENCES + trainData$ORGANIZE +
+ trainData$TYPE + trainData$HOTEL_QUAL
myData_ctree <- ctree(myFormula, data = trainData)
myFormula <- trainData$COMPANIONS ~ trainData$AGE + trainData$CHOICE + trainData$LENGTH + trainData$TIMES_YEAR +
+ trainData$AIM + trainData$EXPENCES + trainData$ORGANIZE +
+ trainData$TYPE + trainData$HOTEL_QUAL
myFormula <- myData
View(myFormula)
myData_ctree <- ctree(myFormula, data = trainData)
remove(list = ls())
myData <- read.csv("C:/Users/GudievZK/Desktop/GitHub/DF/tourism.csv")
set.seed(1234)
ind <- sample(2, nrow(myData), replace = TRUE, prob = c(0.7, 0.3)) #
trainData <- myData[ind == 1, ]
testData<- myData[ind == 2, ]
factorNames <- names(select_if(myData, is.character))
myData[, factorNames] <- lapply(myData[factorNames], factor)
myFormula <- trainData$AGE ~ trainData$COMPANIONS + trainData$CHOICE + trainData$LENGTH + trainData$TIMES_YEAR +
+ trainData$AIM + trainData$EXPENCES + trainData$ORGANIZE +
+ trainData$TYPE + trainData$HOTEL_QUAL
myFormula <- myData
myData_ctree <- ctree(myFormula, data = trainData)
library(readxl)
remove(list = ls())
yt <- read_xlsx('/Users/zelimkhan/Desktop/Data/GitHub/DF/plan.xlsx', sheet = 'Worksheet')
yt <- read_xlsx('/Users/zelimkhan/Desktop/Data/GitHub/DF/plan.csv.xlsx', sheet = 'Worksheet')
yt <- read_xlsx('/Users/zelimkhan/Desktop/Data/GitHub/DF/plan.csv.xlsx', sheet = 'Worksheet')
remove(list = ls())
setwd("/Users/zelimkhan/Desktop/Data/GitHub/DF/")
setwd("C:/Users/GudievZK/Desktop/GitHub/DF/")
yt <- read_xlsx('/Users/zelimkhan/Desktop/Data/GitHub/DF/plan.csv.xlsx', sheet = 'Worksheet')
yt <- read_xlsx('C:/Users/GudievZK/Desktop/GitHub/DF/plan.csv.xlsx', sheet = 'Worksheet'')
# Удаление ненужных столбцов
names(yt)
yt <- select(yt, "ID задачи", "Заголовок", "Основание", "План по стандартизации", "Квартал", "Вид ТЗ", "Stage",
"Количество возвратов от ДЭПиР", "Количество возвратов от ОИВ", "Исполнитель", "Руководитель группы",
"Курирующий заместитель руководителя ПО", "Исполнитель ДЭПиР", "Контракт", "ПЦП", "Критерии оценки",
"Форма 2", "Способы определения поставщика (подрядчика, исполнителя)", "Теги", "КТД", "Дата создания",
"Время нахождения в статусе \"В работе АЦ\"", "Время нахождения в статусе \"Доработка ОИВ\"",
"Время нахождения в статусе \"Доработка ДЭПиР\"", "Время нахождения в статусе \"Внут. согл.\"",
"Время нахождения в статусе \"В ДЭПиР\"", "Время нахождения в статусе \"На согл. в ОИВ\"",
"Время нахождения в статусе \"Подготовка к РГ\"", "Время нахождения в статусе \"РГ\"",
"Время нахождения в статусе \"МРГ\"", "Время нахождения в статусе \"Загрузка в ЕАИСТ\"",
"Длительность")
yt <- filter(yt, yt$Теги != "Не полностью YouTrackная")
yt <- filter(yt, yt$Stage == "Завершено")
yt <- select(yt, "ID задачи", "Заголовок", "Основание", "План по стандартизации", "Квартал", "Вид ТЗ", "Stage",
"Количество возвратов от ДЭПиР", "Количество возвратов от ОИВ", "Исполнитель", "Руководитель группы",
"Курирующий заместитель руководителя ПО", "Исполнитель ДЭПиР", "Контракт", "ПЦП", "Критерии оценки",
"Форма 2", "Способы определения поставщика (подрядчика, исполнителя)", "Теги", "КТД", "Дата создания",
"Время нахождения в статусе \"В работе АЦ\"", "Время нахождения в статусе \"Доработка ОИВ\"",
"Время нахождения в статусе \"Доработка ДЭПиР\"", "Время нахождения в статусе \"Внут. согл.\"",
"Время нахождения в статусе \"В ДЭПиР\"", "Время нахождения в статусе \"На согл. в ОИВ\"",
"Время нахождения в статусе \"Подготовка к РГ\"", "Время нахождения в статусе \"РГ\"",
"Время нахождения в статусе \"МРГ\"", "Время нахождения в статусе \"Загрузка в ЕАИСТ\"",
"Длительность")
yt <- rename(yt,
id = "ID задачи", name = "Заголовок", reason = "Основание", year_plan_st = "План по стандартизации",
kvartal = "Квартал", kind_tz = "Вид ТЗ", stage = "Stage", numb_ret_depir = "Количество возвратов от ДЭПиР",
numb_ret_oiv = "Количество возвратов от ОИВ", executor_ac = "Исполнитель", teamleader = "Руководитель группы",
deputy = "Курирующий заместитель руководителя ПО", executor_depir = "Исполнитель ДЭПиР", contract = "Контракт",
pcp = "ПЦП", criteria = "Критерии оценки", f2 = "Форма 2", method = "Способы определения поставщика (подрядчика, исполнителя)",
tegs = "Теги", ktd = "КТД", created_date = "Дата создания", time_ac = "Время нахождения в статусе \"В работе АЦ\"",
time_rev_oiv = "Время нахождения в статусе \"Доработка ОИВ\"", time_rev_depir = "Время нахождения в статусе \"Доработка ДЭПиР\"",
time_vn_sogl = "Время нахождения в статусе \"Внут. согл.\"", time_depir = "Время нахождения в статусе \"В ДЭПиР\"",
time_oiv = "Время нахождения в статусе \"На согл. в ОИВ\"", time_prep_rg = "Время нахождения в статусе \"Подготовка к РГ\"",
time_rg = "Время нахождения в статусе \"РГ\"", time_mrg = "Время нахождения в статусе \"МРГ\"",
time_eaist = "Время нахождения в статусе \"Загрузка в ЕАИСТ\"", duration = "Длительность")
names(yt)
str(yt)
# корректирорвка типов
yt_n_names <- c('numb_ret_depir', 'numb_ret_oiv', 'time_plan', 'time_ac', 'time_rev_oiv',
'time_rev_depir', 'time_vn_sogl', 'time_depir', 'time_oiv',
'time_prep_rg', 'time_rg', 'time_mrg', 'time_eaist', 'duration')
yt[, yt_n_names] <- lapply(yt[, yt_n_names], as.numeric)
yt_f_names <- c('reason', 'year_plan_st', 'kvartal', 'kind_tz', 'stage', 'executor_ac',
'teamleader', 'deputy', 'executor_depir', 'contract', 'pcp', 'criteria',
'f2', 'method', 'tegs')
yt[yt_f_names] <- lapply(yt[yt_f_names], as.factor)
write.csv2(yt, file = "yt.csv")
