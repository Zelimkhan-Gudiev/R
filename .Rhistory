1 : 67
my_vector1 <- 1:67
my_vector2 <- c(-32, 45, 67, 12.78, 129, 0, -65)
my_vector1[1]
my_vector1[3]
my_vector2[2]
my_vector2[c(1,2,3)]
1:3
my_vector2[1:3]
my_vector2[c(1,5,6,7,10)]
my_vector1 + 10
my_vector2 + 56
my_vector2 == 0
my_vector1 > 30
x <- 23
my_vector1 > 23
my_vector1 > x
x == 23
my_vector2 > 0
my_vector2[my_vector2 > 0]
my_vector2[my_vector2 < 0]
my_vector2[my_vector2 == 0]
my_vector1[my_vector1 > 20 & my_vector1 < 30]
positive_numbers <- my_vector2[my_vector2 > 0]
my_vector2
positive_numbers
v1 <-  c(165, 178, 180, 181, 167, 178, 187, 167, 187)
mean_v1 <- mean(v1)
mean_v1
v1[v1 > mean_v1]
greater_than_mean <- v1[v1 > mean_v1]
greater_than_mean
age <- c(16, 18, 22, 27)
is_maried <- c(F, F, T, T)
name <- c("Olga", "Maria", "Nastya", "Polina")
data <- list(age, is_maried, name)
View(data)
data
View(data)
data[[1]][1]
View(data)
data[[2]][3]
df <- data.frame(Name = name, Age = age, Status = is_maried)
View(df)
head(df)
typeof(df)
mydata <- read.csv('evals.csv')
source("~/Desktop/Data/GitHub/1.3_my_script.R")
source("~/Desktop/Data/GitHub/1.3_my_script.R")
my_var1  <- 42 # создаем переменные
my_var2  <- 35.25 # создаем переменные
# с переменными можно работать
my_var1 + 100 # 42 + 100 = 142
my_var1 + my_var2 - 12 # 42 + 35.25 = 65.25
my_var3  <- my_var1^2 + my_var2^2 # 42^2 + 35.25^2 = 3006.562
#### Step 3: Logical operations _______________________________________________________________________________________________________________ ####
my_var3 > 200 # Правда ли, что my_var3 (3006.562) больше чем 200? Ответ: TRUE
my_var3 > 3009 # Правда ли, что my_var3 (3006.562) больше чем 200? Ответ: FALSE
my_var1 == my_var2 # Правда ли, что my_var1 (42) равна my_var2 (35.25)? Ответ: FALSE
my_var1 != my_var2 # Правда ли, что my_var1 (42) НЕ равна my_var2 (35.25)? Ответ: TRUE
my_var3 >= 200 # Правда ли, что my_var3 (3006.562) больше или равна 200? Ответ: TRUE
my_var3 <= 200 # Правда ли, что my_var3 (3006.562) меньше или равна 200? Ответ: FALSE
my_new_var  <- my_var1 == my_var2 # результат выполенения логических операций можно сохранять в переменные
#### Приммечание == ___________________________________________________________________________________________________________________________ ####
# знак ==  используется для сравнения. 1 == 2 Ответ: нет
# знак = используется для присвоения. а = 2 Результат в переменной а сохрарено число 2
#### Step 7 of 16. Задача ####
# В уже созданных переменных number_1, number_2 и number_3, сохранены целые числа.
# Проверьте, действительно ли сумма первых двух чисел строго больше, чем третье число.
# Результат сравнения (TRUE или FALSE) сохраните в новую переменную с именем result.
sum_1_2 <- number_1 + number_2 # Переменные number_1, number_2, number_3 уже созданы в невидимой для вас части кода!:)
result <- sum_1_2 > number_3
#### Step 6, 7, 10, 11: Vectors _______________________________________________________________________________________________________________ ####
1 : 67 # создаем вектор (последовательность чисел)
my_vector1  <- 1:67 # создаем переменную и сохраняем в нее вектор (последовательность чисел)
my_vector2  <- c(-32, 45, 67, 12.78, 129, 0, -65) # если хотим сами указать числа последовательности, то испольуем ф. "c" (Combine)
?c  # Combine Values into a Vector or List
#### Step 9 of 16. Обращение к элементам вектора _______________________________________________________________________________________________####
my_vector1[1] # чему равняется первый элемент вектора my_vector1
my_vector1[3] # чему равняется третий элемент вектора my_vector1
my_vector2[2] # чему равняется второй элемент вектора my_vector2
my_vector2[c(1,2,3)] # выводим 1, 2 и 3 элемент my_vector2. Чтобы обратиться к нескольким элементам нужно
# в индексе указывать вектор [c(1,2,3)]
my_vector2[1:3] # выводим 1, 2 и 3 элемент my_vector2. Чтобы обратиться к нескольким элементам нужно
# в индексе указывать вектор [1:3]
my_vector2[c(1,5,6,7,10)] # выводим 1,5,6,7,10 элемент my_vector2. 10 - NA
#### Step 10 of 16. Обращение к элементам вектора ______________________________________________________________________________________________####
# При помощи функции с() мы можем объединять не только несколько чисел, но сразу несколько векторов. Например:
vector_1 <- c(1,2,3)
vector_2 <- c(4,5,6)
vector_3 <- c(vector_1, vector_2)
# Данная операция называется конкатенацией векторов. В результате vector_3 будет содержать последовательность чисел от 1 до 6.
# Создайте переменную the_best_vector, в которой хранятся числа от 1 до 5000 и затем числа от 7000 до 10000.
# v1
vector_1 <- c(1:5000)
vector_2 <- c(7000:10000)
the_best_vector <- c(vector_1, vector_2)
# v2
the_best_vector <- c(1:5000, 7000:10000)
#### Step 11 of 16. Задача. Обращение к элементам вектора ______________________________________________________________________________________####
# В уже созданной переменной my_numbers сохранен вектор из 20 целых чисел.
# Ваша задача создать новую переменную my_numbers_2, в которой будет сохранен
# 2, 5, 7, 9, 12, 16 и 20 элемент вектора my_numbers.
my_numbers_2 <- my_numbers[c(2, 5, 7, 9, 12, 16 и 20)]
#### Step 12 of 16. Обращение к элементам с помощью логических операций ________________________________________________________________________####
my_vector1 + 10 # с векторами можно выполнять арифметические операции.
my_vector2 + 56 # арифметическая операция выполняется с каждым элементом вектора. Получаем новый вектор (в консоле),
# элементы которого это результат выполления арифметической операции над каждым элементом исходного вектора
my_vector2 == 0 # с векторами можно выполнять логичекие операции
my_vector1 > 30 # логичекая операция выполняется с каждым элементом вектора. Получаем новый вектор (в консоле),
# элементы которого это результат выполления логической операции над каждым элементом исходного вектора
# Можно полностью уйти от числ и использовать вместо них переменные
x  <- 23
my_vector1 > x # сравниваеи 23 с my_vector1 <- vector_1 <- c(1:5000). Получаем новый логический вектор
x == 23 # сравниваеи x == 23. Ответ TRUE.
# Таким образом, при выполнении опреций с векторами, такие операции выполняются в отношении каждого
# элемента вектора и на выход получаем новый вектор. Понимание данного принципа важно для понимания
# процесса обращения к элементам вектора. Мы можем обращаться к элементам, которые отвечают определенным
# условиям (соответствуют вектору указанному в индексе)
my_vector2
my_vector2[my_vector2 > 0] # новый вектор используем для индексации, т.е. используем один вектор для
# обращания к элементам другого вектора
my_vector2[my_vector2 < 0] # берем вектор из отрицательных элементов my_vector2 и обращаемся с помощь него к my_vector2.
# Результат получаем новый вектор, который состоит из отрицательных элементов my_vector2
my_vector2[my_vector2 == 0]
# Результат получаем новый вектор, который состоит из отрицательных элементов my_vector2
my_vector2[my_vector2 == 1]
my_vector1
# к элеменам вектора можно обращаться с использованием сложных условий
my_vector1[my_vector1 > 20 & my_vector1 < 30]
my_numbers  <- my_vector1[my_vector1 > 20 & my_vector1 < 30]
my_numbers
positive_numbers  <- my_vector2[my_vector2 > 0]
positive_numbers
# пример
v1  <- c(165, 178, 180, 181, 167, 178, 187, 167, 187) # сохраним данные в перемменную v1
mean_v1  <- mean(v1) # сохраним в переменную mean_v1 ср. ариф всех значений перемменной v1
mean_v1
v1
v1[v1 > mean_v1]
greater_than_mean  <- v1[v1 > mean_v1] #  новый логический вектор, сохранен в новую переменную greater_than_mean
greater_than_mean
greater_than_10 <- my_vector[my_vector > 10]
greater_than_10 <- my_vector[my_vector > 10]
my_vector <- seq(1:200, by = 10)
my_vector <- seq(1, 200, by = 10)
my_vector
my_vector <- seq(1, 200, by = 9)
my_vector
my_vector <- seq(0, 200, by = 10)
my_vector
greater_than_10 <- my_vector[my_vector > 10]
greater_than_10
my_sum <- sum(greater_than_10)
my_sum
is_maried  <- c(F, F, T, T)
is_maried
name  <- c("Olga", "Maria", "Nastya", "Polina")
age  <- c(16, 18, 22, 27)
name
age  <- c(16, 18, 22, 27)
my_data  <- data.frame(Name = name, Age = age, Status = is_maried)
my_data
typeof(my_data) # list, т.к. данный дф содержит данные разного типа
my_vector <- seq(1, 20, by = 1)
greater_than_10 <- my_vector[my_vector > 10]
my_sum <- sum(greater_than_10)
my_sum
my_data <- read.csv('https://stepik.org/media/attachments/lesson/11481/evals.csv')
yt <- read.csv2("yt.csv")
head(my_data) # комманда head по умолчанию выводит шесть первых строк
head(my_data, 7) # через запятую можно указать сколько строк выводить
tail(my_data) # комманда tail по умолчанию выводит шесть последних строк
tail(my_data, 7) # через запятую можно указать сколько строк выводить
View(my_data) # функция View позволяет увидеть 1000 наблюдений (строк)
str(my_data) # показывает внутреннюю структуру объекта R
summary(my_data) # показывает некоторые сводные данные (описательные статистики для кол. переменных) дата фрейма
names(my_data)
myData <- iris
sum(is.na(myData)) # NA отсутствуют
myData[c(1, 3, 51), c(2, 4)] <- NA # заменим некоторые данные на NA
is.na(myData)
sum(is.na(myData)) # 6 NA
myDataNA <- myData # сохраним дата фрейм с пропусками, т.к. мы его использовать вместо исходного файла
myData[!complete.cases(myData),] # ропуски имеются на пересечении строк 1, 3 и 51 и столбцов Sepal.Width Petal, Petal.Width
# Примите решение, что, на ваш взгляд, целесообразно в данном случае сделать с пропущенными значениями.
# В частности, подставьте вместо отсутствующих значений среднее с помощью функции na.aggregate либо удалите значения с пропусками.
myData[] <- lapply(myData_NA, na.aggregate)
sum(is.na(myData)) # 0 NA
# Кратко ответьте на следующие вопросы.
#  1)	Что является элементарной единицей в этом наборе данных?
# Ответ: один цветок
#  2)	Определите вид данных: одномерные, двумерные, многомерные?
dim(myData)
# Ответ: двумерные данные.
#  3)	Определите какие из этих переменных количественные, а какие качественные?
str(myData)
# library(dplyr)
colnames(select_if(myData, is.numeric)) # "Sepal.Length" "Sepal.Width"  "Petal.Length" "Petal.Width"
colnames(select_if(myData, is.factor)) #  "Species"
# Ответ: "Sepal.Length" "Sepal.Width"  "Petal.Length" "Petal.Width"
#  4)	Какие из этих переменных номинальные? Какие порядковые?
# Ответ:
#  5)	Это временной ряд или данные об одном временном срезе?
# Ответ:
#  6)	Укажите, какие операции можно применять к каждой из переменных
# Ответ:
#  7)	Сформулируйте (в общих терминах), на какие вопросы можно найти ответы при детальном анализе набора данных такого типа.
# Ответ:
# Проверьте количество наблюдений и переменных.
dim(myData) # 150 наблюдений и 50 переменных
# Проверьте названия переменных.
names(myData) # "Sepal.Length" "Sepal.Width"  "Petal.Length" "Petal.Width"  "Species"
# Проверьте структуру данных. В частности, количественные переменные должны иметь атрибут «числовая»,
# качественные – «factor», а также являются ли данные таблицей или фреймом.
str(myData)
colnames(select_if(myData, is.numeric)) # количественные: "Sepal.Length" "Sepal.Width"  "Petal.Length" "Petal.Width"
colnames(select_if(myData, is.factor)) #  качественные: "Species"
typeof(myData) # "list"
class(myData)  # "data.frame"
attributes(myData)
# Рассчитайте описательные статистики.
summary(myData)
# Рассчитайте винзорированную (триммированную) среднюю по каждой переменной и сопоставьте это значение с исходным средним
# медианным значением. Сделайте выводы.
winsor.mean(select_if(myData, is.numeric), trim = 0.2, na.rm = TRUE)
winsor.mean(select_if(myData, is.numeric), trim = 0.2, na.rm = TRUE)
library("psych")
library(zoo)
library(dplyr)
myData <- iris
#### 1.3 Проверьте, есть ли наблюдения, в которых значения по какому-либо параметру отсутствуют, и выведите список этих значений. ####
sum(is.na(myData)) # NA отсутствуют
myData[c(1, 3, 51), c(2, 4)] <- NA # заменим некоторые данные на NA
is.na(myData)
sum(is.na(myData)) # 6 NA
myDataNA <- myData # сохраним дата фрейм с пропусками, т.к. мы его использовать вместо исходного файла
myData[!complete.cases(myData),] # ропуски имеются на пересечении строк 1, 3 и 51 и столбцов Sepal.Width Petal, Petal.Width
# Примите решение, что, на ваш взгляд, целесообразно в данном случае сделать с пропущенными значениями.
# В частности, подставьте вместо отсутствующих значений среднее с помощью функции na.aggregate либо удалите значения с пропусками.
myData[] <- lapply(myData_NA, na.aggregate)
sum(is.na(myData)) # 0 NA
# Кратко ответьте на следующие вопросы.
#  1)	Что является элементарной единицей в этом наборе данных?
# Ответ: один цветок
#  2)	Определите вид данных: одномерные, двумерные, многомерные?
dim(myData)
# Ответ: двумерные данные.
#  3)	Определите какие из этих переменных количественные, а какие качественные?
str(myData)
# library(dplyr)
colnames(select_if(myData, is.numeric)) # "Sepal.Length" "Sepal.Width"  "Petal.Length" "Petal.Width"
colnames(select_if(myData, is.factor)) #  "Species"
# Ответ: "Sepal.Length" "Sepal.Width"  "Petal.Length" "Petal.Width"
#  4)	Какие из этих переменных номинальные? Какие порядковые?
# Ответ:
#  5)	Это временной ряд или данные об одном временном срезе?
# Ответ:
#  6)	Укажите, какие операции можно применять к каждой из переменных
# Ответ:
#  7)	Сформулируйте (в общих терминах), на какие вопросы можно найти ответы при детальном анализе набора данных такого типа.
# Ответ:
# Проверьте количество наблюдений и переменных.
dim(myData) # 150 наблюдений и 50 переменных
# Проверьте названия переменных.
names(myData) # "Sepal.Length" "Sepal.Width"  "Petal.Length" "Petal.Width"  "Species"
# Проверьте структуру данных. В частности, количественные переменные должны иметь атрибут «числовая»,
# качественные – «factor», а также являются ли данные таблицей или фреймом.
str(myData)
colnames(select_if(myData, is.numeric)) # количественные: "Sepal.Length" "Sepal.Width"  "Petal.Length" "Petal.Width"
colnames(select_if(myData, is.factor)) #  качественные: "Species"
typeof(myData) # "list"
class(myData)  # "data.frame"
attributes(myData)
# Рассчитайте описательные статистики.
summary(myData)
# Рассчитайте винзорированную (триммированную) среднюю по каждой переменной и сопоставьте это значение с исходным средним
# медианным значением. Сделайте выводы.
winsor.mean(select_if(myData, is.numeric), trim = 0.2, na.rm = TRUE)
modMed <- summary(myData)
rm(modMed)
modMed <- summary(myData)
modMed
modMed[c(median, means), -5]
modMed[c(median, mean), -5]
modMed[c(modMed$median, modMed$mean), -5]
modMed <- summary(myData)
modMed
rm(modMed)
aggregate(myDataNA, FUN = c(mean, median()))
mean(select_if(myData, is.numeric))
mean(select_if(myData, is.numeric)
means(select_if(myData, is.numeric)
means(select_if(myData, is.numeric))
mean(select_if(myData, is.numeric))
winsor.mean(select_if(myDataNA, is.numeric), trim = 0.2, na.rm = TRUE)
mean(select_if(myData, is.numeric))
mean(select_if(myData, is.numeric))
mean(myData$Sepal.Length)
mean(c(myData$Sepal.Length, myData$Sepal.Width, myData$Petal.Length, myData$Petal.Width)
mean(c(myData$Sepal.Length, myData$Sepal.Width, myData$Petal.Length, myData$Petal.Width))
mean(myData$Sepal.Length, myData$Sepal.Width, myData$Petal.Length, myData$Petal.Width)
myData
names(myData)
aggregate(cbind(Sepal.Length, Sepal.Width),  myData, sd)
aggregate(cbind('Sepal.Length', 'Sepal.Width'),  myData, sd)
aggregate(cbind('Sepal.Length', 'Sepal.Width'),  myData, mean)
describe(myData)
describe
describe(myDataNA)
describe(myDataNA)[-5, 3]
winsor.mean(select_if(myDataNA, is.numeric), trim = 0.2, na.rm = TRUE)
names(myData)
winsor.mean(select_if(myDataNA, is.numeric), trim = 0.2, na.rm = TRUE)
describe(myDataNA)
describe(myDataNA[, -5])
describe(myDataNA[, -5])['mean']
describe(myDataNA[, -5])['mean', 'sd']
describe(myDataNA[, -5])['mean', 'median']
describe(myDataNA[, -5])[c('mean', 'median')]
describe(myDataNA[, -5])[c('mean', 'median')]
winsor.mean(select_if(myDataNA, is.numeric), trim = 0.2, na.rm = TRUE)
as.data.frame(winsor.mean(select_if(myDataNA, is.numeric), trim = 0.2, na.rm = TRUE))
as.data.frame(winsor.mean(select_if(myData, is.numeric), trim = 0.2, na.rm = TRUE))
describe(myDataNA[, -5])[c('mean', 'median')]
# Проверьте данные на наличие выбросов по каждой переменной, присвоив ей буквенное значение (x1, х2, х3…).
x1 <- myData[, 1]
boxplot.stats(x1)$out
boxplot(x1)
# Значения, которые являются выбросами для всех переменных:
df <- data.frame(x1, х2, х3, х4)
x2 <- myData[, 2]
boxplot.stats(x2)$out
boxplot(x2)
x3 <- myData[, 3]
boxplot.stats(x3)$out
boxplot(x3)
x4 <- myData[, 4]
boxplot.stats(x4)$out
boxplot(x4)
boxplot(x3)
x4 <- myData[, 4]
boxplot.stats(x4)$out
boxplot(x4)
boxplot.stats(x3)$out
boxplot.stats(x4)$out
boxplot.stats(x2)$out
df <- data.frame(x1, х2, х3, х4)
x2 <- myData[, 2]
boxplot.stats(x2)$out
boxplot(x2)
# Значения, которые являются выбросами для всех переменных:
df <- data.frame(x1, х2, х3, х4)
# Значения, которые являются выбросами для всех переменных:
df <- data.frame(x1, x2, х3, х4)
# Значения, которые являются выбросами для всех переменных:
df <- data.frame(x1, x2, x3, x4)
df
rm(x1,х2,х3,х4)
attach(df)
(a <- which(x1 %in% boxplot.stats(x1)$out))
rm(x1,х2,х3,х4)
attach(df)
a <- which(x1 %in% boxplot.stats(x1)$out)
a <- which(x1 %in% boxplot.stats(x1)$out)
a
(a <- which(SEPALLEN%in% boxplot.stats(SEPALLEN)$out))
a <- which(SEPALLEN%in% boxplot.stats(SEPALLEN)$out)
df
df <- data.frame(x1, x2, x3, x4)
a <- which(x1 %in% boxplot.stats(x1)$out)
a
b <- which(х2 %in% boxplot.stats(х2)$out)
(b <- which(х2 %in% boxplot.stats(х2)$out))
(c<- ……….
(a <- which(x1 %in% boxplot.stats(x1)$out))
(b <- which(х2 %in% boxplot.stats(x2)$out))
(a <- which(x1 %in% boxplot.stats(x1)$out))
(b <- which(x2 %in% boxplot.stats(x2)$out))
boxplot.stats(x4)$out
boxplot.stats(x2)$out
(c<-  which(x3 %in% boxplot.stats(x3)$out))
(c <-  which(x3 %in% boxplot.stats(x3)$out))
(d <-  which(x4 %in% boxplot.stats(x4)$out))
d <-  which(x4 %in% boxplot.stats(x4)$out)
(d <-  which(x4 %in% boxplot.stats(x4)$out))
detach(df)
df
outlier.list1 <- intersect(х1,х2,х3,х4))
df
outlier.list1 <- intersect(х1,х2,х3,х4))
oulier_list1 <- Reduce(intersect, list(a,b,c,d))
oulier_list2 <- Reduce(union, list(a,b,c,d))
oulier_list1
oulier_list2
# Для выделения выбросов необходимо убрать, при ее наличии, качественную переменную, записав данные под новым именем:
myData2 <- myData[,1:4]
head(myData2)
kmeans.result <- kmeans(myData2, centers = 3)
# Проведите кластеризацию методом К-средних, выделив три кластера:
kmeans.result <- kmeans(myData2, centers = 3, na.rm = T)
# Проведите кластеризацию методом К-средних, выделив три кластера:
kmeans.result <- kmeans(myData2, centers = 3)
head(df)
View(myDataNA)
# Проведите кластеризацию методом К-средних, выделив три кластера:
kmeans.result <- kmeans(df, centers = 3)
df <- data.frame(x1, x2, x3, x4)
kmeans.result <- kmeans(df, centers = 3)
# Проведите кластеризацию методом К-средних, выделив три кластера:
is.na(df)
# Проведите кластеризацию методом К-средних, выделив три кластера:
sum(is.na(df))
# Проведите кластеризацию методом К-средних, выделив три кластера:
sum(is.na(myData))
myData[] <- lapply(myData_NA, na.aggregate)
sum(is.na(myData)) # 0 NA
myData[] <- lapply(myData_NA, na.aggregate)
myData[] <- lapply(myDataNA, na.aggregate)
sum(is.na(myData)) # 0 NA
x1 <- myData[, 1]
boxplot.stats(x1)$out
boxplot(x1)
x2 <- myData[, 2]
boxplot.stats(x2)$out
boxplot(x2)
x3 <- myData[, 3]
boxplot.stats(x3)$out
boxplot(x3)
x4 <- myData[, 4]
boxplot.stats(x4)$out
boxplot(x4)
# Значения, которые являются выбросами для всех переменных:
df <- data.frame(x1, x2, x3, x4)
rm(x1,х2,х3,х4)
rm(x1, x2, x3, x4)
# Проведите кластеризацию методом К-средних, выделив три кластера:
sum(is.na(myData))
kmeans.result <- kmeans(df, centers = 3)
kmeans.result
# Отобразите центры кластеров:
kmeans.result$centers
# Рассчитайте расстояния от объектов до центров кластеров:
centers <- kmeans.result$centers[kmeans.result$cluster, ]
distances <- sqrt(rowSums((myData2 - centers)^2))
centers
distances
distances <- sqrt(rowSums((myData - centers)^2))
distances
# Рассчитайте расстояния от объектов до центров кластеров:
centers <- kmeans.result$centers[kmeans.result$cluster, ]
distances <- sqrt(rowSums((myData - centers)^2))
myData <- myData[, 1:4]
# Проведите кластеризацию методом К-средних, выделив три кластера:
sum(is.na(myData))
kmeans.result <- kmeans(df, centers = 3)
kmeans.result
# Рассчитайте расстояния от объектов до центров кластеров:
centers <- kmeans.result$centers[kmeans.result$cluster, ]
centers
distances <- sqrt(rowSums((myData - centers)^2))
distances
# Возьмите несколько (например, 5) наибольших получившихся расстояний.
outliers <- order(distances, decreasing=T)[1:5]
outliers
print(outliers)
print(myData[outliers, ])
plot(iris2[,c("Sepal.Length", "Sepal.Width")], pch="o", col=kmeans.result$cluster, cex=0.3)
points(kmeans.result$centers[,c("Sepal.Length", "Sepal.Width")], col=1:3, pch=8, cex=1.5)
points(iris2[outliers, c("Sepal.Length", "Sepal.Width")], pch="+", col=4, cex=1.5)
plot(iris2[,c("Sepal.Length", "Sepal.Width")], pch="o", col=kmeans.result$cluster, cex=0.3)
plot(myData[,c("Sepal.Length", "Sepal.Width")], pch="o", col=kmeans.result$cluster, cex=0.3)
plot(myData[, c("Sepal.Length", "Sepal.Width")], pch ="o", col = kmeans.result$cluster, cex = 0.3)
points(kmeans.result$centers[, c("Sepal.Length", "Sepal.Width")], col = 1:3, pch = 8, cex = 1.5)
points(myData[outliers, c("Sepal.Length", "Sepal.Width")], pch = "+", col = 4, cex = 1.5)
points(kmeans.result$centers[, c("Sepal.Length", "Sepal.Width")], col = 1:3, pch = 8, cex = 1.5)
points(kmeans.result$centers[, c("Sepal.Length", "Sepal.Width")], col = 1:3, pch = 8, cex = 1.5)
plot(myData[, c("Sepal.Length", "Sepal.Width")], pch ="o", col = kmeans.result$cluster, cex = 0.3)
points(kmeans.result$centers[, c("Sepal.Length", "Sepal.Width")], col = 1:3, pch = 8, cex = 1.5)
points(myData[outliers, c("Sepal.Length", "Sepal.Width")], pch = "+", col = 4, cex = 1.5)
plot(myData[, c("Sepal.Length", "Sepal.Width")], pch ="o", col = kmeans.result$cluster, cex = 0.3)
print(myData[outliers, ])
print(myData[outliers, ])
plot(myData[, c("Sepal.Length", "Sepal.Width")], pch ="o", col = kmeans.result$cluster, cex = 0.3)
points(kmeans.result$centers[, c("Sepal.Length", "Sepal.Width")], col = 1:3, pch = 8, cex = 1.5)
points(kmeans.result$centers[, c("Sepal.Length", "Sepal.Width")], col = 1:3, pch = 8, cex = 1.5)
kmeans.result$centers
points(kmeans.result$centers[, c("Sepal.Length", "Sepal.Width")], col = 1:3, pch = '8', cex = 1.5)
points(kmeans.result$centers[, c("Sepal.Length", "Sepal.Width")], col = 1:3, pch = "8", cex = 1.5)
kmeans.result$centers[, c("Sepal.Length", "Sepal.Width")]
plot(myData[, c("Sepal.Length", "Sepal.Width")], pch ="o", col = kmeans.result$cluster, cex = 0.3)
points(kmeans.result$centers[, c("x1", "x2")], col = 1:3, pch = 8, cex = 1.5)
points(myData[outliers, c("Sepal.Length", "Sepal.Width")], pch = "+", col = 4, cex = 1.5)
print(myData[outliers, ])
# Кратко опишите, какие наблюдения являются аномальными:
# Ответ:
names(myData[outliers, ])
# Кратко опишите, какие наблюдения являются аномальными:
# Ответ:
rownames(myData[outliers, ])
oulier_list1
oulier_list2
# Кратко опишите, какие наблюдения являются аномальными:
# Ответ:
rownames(myData[outliers, ]) # "99",  "58", "94", "61", "119"
oulier_list1 <- Reduce(intersect, list(a,b,c,d))
oulier_list1
oulier_list2
oulier_list2
outliers <- order(distances, decreasing=T)[1:5]
outliers
sqrt(rowSums((myData - centers)^2))
